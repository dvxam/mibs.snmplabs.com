#
# PySNMP MIB module A3COM-RIP-IPEXTNS-R4-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/tin/Dev/mibs.snmplabs.com/asn1/A3COM-RIP-IPEXTNS-R4-MIB
# Produced by pysmi-0.3.4 at Fri Jan 31 21:33:20 2020
# On host bier platform Linux version 5.4.0-3-amd64 by user tin
# Using Python version 3.7.6 (default, Jan 19 2020, 22:34:52) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
iso, IpAddress, TimeTicks, Counter32, ObjectIdentity, Counter64, Gauge32, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, ModuleIdentity, Unsigned32, MibIdentifier, enterprises, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "IpAddress", "TimeTicks", "Counter32", "ObjectIdentity", "Counter64", "Gauge32", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "ModuleIdentity", "Unsigned32", "MibIdentifier", "enterprises", "Bits")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
a3Com = MibIdentifier((1, 3, 6, 1, 4, 1, 43))
brouterMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2))
a3ComRipIp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 8))
class RowStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6))

a3RipIpUpdateTime = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 5400)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpUpdateTime.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpUpdateTime.setDescription('This parameter specifies the time interval, in seconds, within which RIP-IP sends update packets. This parameter also determines the length of time a route learned through RIP-IP stays in the IP routing table. For example, once a route is in the routing table, the router must receive a RIP update packet indicating the reachability of this route every 6 * a3RipIpUpdateTime. If no updates are received in that time interval, the entry is removed from the routing table.')
a3RipIpCtlTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 8, 2), )
if mibBuilder.loadTexts: a3RipIpCtlTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpCtlTable.setDescription('This table contains parameters that affect the operation of RIP for IP.')
a3RipIpCtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1), ).setIndexNames((0, "A3COM-RIP-IPEXTNS-R4-MIB", "a3RipIpPortIndex"))
if mibBuilder.loadTexts: a3RipIpCtlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpCtlEntry.setDescription('Each entry contains parameters specific to each network port on this system.')
a3RipIpPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3RipIpPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpPortIndex.setDescription('This provides the port index to which the RIP-IP parameters in this table entry apply.')
a3RipIpTalkCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("talk", 1), ("noTalk", 2))).clone('noTalk')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpTalkCtl.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: CONTol.')
if mibBuilder.loadTexts: a3RipIpTalkCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpTalkCtl.setDescription('If talk (1) is specified, RIP-IP sends update and request packets on the specified port. If noTalk (2) is specified, no updates or requests are sent over this port. If talk(1) is specified, 3RipIpDynNbrCtl has been set to dynamicNbr, and the -PORT owner has been set to FR/X.25, the -RIP Neighbor list is built from the ARP table.')
a3RipIpListenCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("listen", 1), ("noListen", 2))).clone('noListen')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpListenCtl.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: CONTol.')
if mibBuilder.loadTexts: a3RipIpListenCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpListenCtl.setDescription('If listen (1) is selected, RIP-IP receives and processes incoming update and request packets. If a3RipIpTalkCtl is set to noTalk (2), this system does not send any response packets for the request packets it receives.')
a3RipIpTrustedNbrCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("include", 1), ("exclude", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpTrustedNbrCtl.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: TrustedNeighbor.')
if mibBuilder.loadTexts: a3RipIpTrustedNbrCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpTrustedNbrCtl.setDescription('This object controls how the list of trusted neighbors in a3RipIpTrustedNbrTable is to be interpreted. If this is set to include (1), RIP-IP will accept routing packets from the set of addresses in a3RipIpTrustedNbrTable. If this is set to exclude (2), RIP-IP will accept routing packets from all addresses except those listed in that table for this port. Note, if a3RipIpTrustedNbrTable is empty, RIP-IP will accept routing updates from all neighbors, regardless of the value of this object.')
a3RipIpPoisonCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("poison", 1), ("noPoison", 2))).clone('poison')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpPoisonCtl.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: CONTol.')
if mibBuilder.loadTexts: a3RipIpPoisonCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpPoisonCtl.setDescription('This parameter determines how split horizon is performed. To achieve split horizon, RIP-IP refrains from advertising a route to a port if the gateway for this route can be reached on the same port. If poison (1) is selected, RIP-IP advertises the route but it uses infinity (16) for the metric. If noPoison (2) is selected, the route is not advertised.')
a3RipIpTriggerCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("trigger", 1), ("noTrigger", 2))).clone('trigger')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpTriggerCtl.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: CONTol.')
if mibBuilder.loadTexts: a3RipIpTriggerCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpTriggerCtl.setDescription("This parameter determines if RIP-IP sends trigger update packets. Trigger update packets are sent when a route's metric has changed. By sending these update packets, RIP does not need to wait for the update interval, allowing earlier notification that a route's metric has changed.")
a3RipIpDefMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpDefMetric.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: DefaultMetric.')
if mibBuilder.loadTexts: a3RipIpDefMetric.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpDefMetric.setDescription('This parameter specifies whether RIP-IP advertises the default route. The default route is the network with internet address 0.0.0.0 and is reported with a metric equal to the value of this parameter. If this is set to 0, the default route is advertised only if it was learned and if that default route is allowed by the corresponding policies.')
a3RipIpExtPolCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("all", 1), ("none", 2), ("include", 3), ("exclude", 4))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpExtPolCtl.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: ExteriorPolicy.')
if mibBuilder.loadTexts: a3RipIpExtPolCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpExtPolCtl.setDescription('This parameter controls which routes learned by the Exterior Gateway Protocol (EGP) are reported by RIP-IP. If this is set to all (1), all routes learned from EGP or BGP are reported, provided those routes are allowed to be reported by the Network Policy (see a3RipIpNetPolCtl). The metric that will be reported by RIP for all routes learned via EGP or BGP is specified by a3RipIpExtPolAllMet. If this is set to none (2), none of the routes learned from EGP or BGP are reported. If this is set to include (3), routes to destinations listed in a3RipIpExtPolTable are reported. If no routes are listed in a3RipIpExtPolTable, all routes are reported. This applies to the other policy tables as well. If this is set to exclude (4), all routes are reported except those listed in a3RipIpExtPolTable. If no routes are listed in a3RipIpExtPolTable, no routes are reported. This applies to the other policy tables as well. The metric reported for routes learned via EGP or BGP in this case is calculated using the formula specified in a3RipIpImpMetTable (for egp or bgp). (note, in all these cases, Network Policy must be passed before this policy is applied). If this objects gets changed from include to exclude, or from exclude to include, all existing entries will be flushed from the table.')
a3RipIpIntPolCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("all", 1), ("none", 2), ("include", 3), ("exclude", 4))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpIntPolCtl.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: InteriorPolicy.')
if mibBuilder.loadTexts: a3RipIpIntPolCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpIntPolCtl.setDescription('This parameter determines which routes learned by an Interior Gateway Protocol (IGP) are reported by RIP-IP. If this is set to all (1), all routes learned from an IGP are reported, provided those routes are allowed to be reported by the Network Policy (see a3RipIpNetPolCtl) The metric that will be reported by RIP for all routes learned via an IGP (other than RIP) is specified by a3RipIpIntPolAllMet. If this is set to none (2), none of the routes learned from the IGP are reported. If this is set to include (3) routes to destinations listed in a3RipIpIntPolTable are reported. If this is set to exclude (4), all routes are reported except those listed in a3RipIpIntPolTable. If no routes are listed, no routes will be reported. The metric reported for routes learned via an IGP (other than RIP) in this case is calculated using the formula specified in a3RipIpImpMetTable (for ospf or iisis). (note, in all these cases, Network Policy must be passed before this policy is applied). If this objects gets changed from include to exclude, or from exclude to include, all existing entries will be flushed from the table.')
a3RipIpNetPolCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("all", 1), ("none", 2), ("include", 3), ("exclude", 4))).clone('all')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpNetPolCtl.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: NetworkPolicy.')
if mibBuilder.loadTexts: a3RipIpNetPolCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpNetPolCtl.setDescription('This parameter determines which routes are reported by RIP-IP. The policies defined by this object and a3RipIpNetPolTable overrides the policies defined in a3RipIpIntPolCtl/Table, a3RipIpExtPolCtl/Table, and a3RipIpStaPolCtl/Table in deciding whether a route is to be reported. If this is set to all (1), all routes are reported, provided they are allowed by either the interior policy or exterior policy. The metric that will be reported by RIP for all routes is specified by a3RipIpNetPolAllMet. If this is set to none (2), none of the routes are reported. If this is set to include (3), routes to destinations listed in a3RipIpNetPolTable are reported. If this is set to exclude (4), all routes are reported except those listed in a3RipIpNetPolTable. If no routes are listed, no routes will be reported. The metric reported for routes learned via RIP in this case is taken directly from the routing table or from the results of applying one of the other policies. (note, in all these cases, the Interior Policy or Exterior Policy must be passed after this policy is applied. Only those routes that pass both sets of policies will be advertised). If this objects gets changed from include to exclude, or from exclude to include, all existing entries will be flushed from the table.')
a3RipIpRcvPolCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("all", 1), ("none", 2), ("include", 3), ("exclude", 4))).clone('all')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpRcvPolCtl.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: ReceivePolicy.')
if mibBuilder.loadTexts: a3RipIpRcvPolCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpRcvPolCtl.setDescription('This parameter is used to filter routing updates from trusted neighbors. It allows control over which RIP routes are received and stored in the routing table. If this is set to all (1), all routes reported by trusted neighbors are received and stored in the routing table. The metric that will be stored in the routing table in this case is specified by a3RipIpRcvPolAllMet. If this is set to none (2), none of the routes are received or stored in the routing table. If this is set to include (3), routes to destinations listed in a3RipIpRcvPolTable are received and stored. If this is set to exclude (4), all routes are received and stored except those listed in a3RipIpRcvPolTable. If this objects gets changed from include to exclude, or from exclude to include, all existing entries will be flushed from the table.')
a3RipIpStaPolCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("all", 1), ("none", 2), ("include", 3), ("exclude", 4))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpStaPolCtl.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: StaticPolicy.')
if mibBuilder.loadTexts: a3RipIpStaPolCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpStaPolCtl.setDescription('This parameter is used to filter the reporting of static routes. It allows control over which static RIP routes are reported. If this is set to all (1), all static routes are reported, provided those routes are allowed to be reported by a3RipIpNetPolCtl/Table. The metric that will be stored in the routing table in this case is specified by a3RipIpStaPolAllMet. If this is set to none (2), none of the static routes are reported. If this is set to include (3), static routes to destinations listed in a3RipIpStaPolTable are reported. If this is set to exclude (4), all routes are reported except those listed in a3RipIpStaPolTable. (note, in all these cases, Network Policy must be passed before this policy is applied). If this objects gets changed from include to exclude, or from exclude to include, all existing entries will be flushed from the table.')
a3RipIpUnnAdvCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("subnetAdvUnn", 1), ("netAdvUnn", 2))).clone('subnetAdvUnn')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpUnnAdvCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpUnnAdvCtl.setDescription('This parameter specifies which routes are reported by RIP updates sent over an unnumbered link. If this object is set to subnetAdvUnn (1), RIP explicitly reports each subnetted route the system knows about. If this object is set to netAdvUnn (2), RIP reports only the IP network rather than each subnet.')
a3RipIpBcastCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("subnetBcast", 1), ("all1sBcast", 2))).clone('subnetBcast')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpBcastCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpBcastCtl.setDescription('This object specifies the destination IP address to which RIP updates are sent over this port. If this object is set to subnetBcast(1), the RIP advertisement is sent using a directed broadcast IP address as its destination (e.g., 129.213.255.255). If this object has the value all1sBcast, the RIP advertisement is sent using a limited broadcast IP address as its destination (i.e., 255.255.255.255).')
a3RipIpExtPolAllMet = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpExtPolAllMet.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpExtPolAllMet.setDescription('When a3RipIpExtPolCtl is set to all, this object specifies the metric used in RIP updates of routes learned via EGP or BGP. If this object is set to zero, the metric is calculated from the metric learned from EGP or BGP according to the formula defined in the a3RipIpImpMetTable (ie, the entry corresponding to egp or bgp).')
a3RipIpIntPolAllMet = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpIntPolAllMet.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpIntPolAllMet.setDescription('When a3RipIpIntPolCtl is set to all, this object specifies the metric used in RIP updates of routes learned via OSPF or IISIS. If this object is set to zero, the metric is calculated from the metric learned from OSPF or IISIS according to the formula defined in the a3RipIpImpMetTable (ie, the entry corresponding to ospf or iisis).')
a3RipIpNetPolAllMet = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpNetPolAllMet.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpNetPolAllMet.setDescription('When a3RipIpNetPolCtl is set to all, this object specifies the metric used in RIP updates of routes learned via RIP. If this object is set to zero, the metric is taken directly from the routing table.')
a3RipIpRcvPolAllMet = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpRcvPolAllMet.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpRcvPolAllMet.setDescription('When a3RipIpRcvPolCtl is set to all, this object specifies the metric stored in the routing table when routing updates are received via RIP (from trusted neighbors).')
a3RipIpStaPolAllMet = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpStaPolAllMet.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpStaPolAllMet.setDescription('When a3RipIpStaPolCtl is set to all, this object specifies the metric used in RIP updates of static routes (ie, those routes entered by a user). If this object is set to zero, the metric is calculated from the metric specified by the static entry according to the formula defined in the a3RipIpImpMetTable (ie, the entry corresponding to static).')
a3RipIpDynNbrCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dynamicNbr", 1), ("noDynamicNbr", 2))).clone('noDynamicNbr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpDynNbrCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpDynNbrCtl.setDescription("When a3RipIpDynNbrCtl is set to dynamicNbr over FR or X.25, and -RIP CONTrol is set to TALK, the neighbor list is learnt dynamically as InArp learn the IP addresses of the dlcis or as addresses are added to the ARP table. The user need not configure the -RIP Neighbor parameter manually. The dynamicNbr|NoDynamicNbr has no significance for non-FR and non-X.25 media. When a3RipIpDynNbrCtl is set to NodynamicNbr, any neighbor in the neighbor list is deleted and the -RIP neighbor list from the config file is restored onto the neighbor list. When the -PORT owner parameter is changed from a non-FR and non-X.25 owner to FR or X.25, the -RIP Neighbor list was empty, and the -RIP CONTrol had the value TALK for this port, the code automatically sets this object to DynamicNbr, and fills up the neighbor list with the appropriate IP addresses in the ARP table. Note: only those neighbors of the same IP address network number for this port is being copied from the ARP table to this port's neighbor list. If the -PORT owner parameter is changed from a FR/X.25 to a non-FR and non-X25 media, and this object had the value DynamicNbr, the code automatically changes this object value to NoDynamicNbr and restores the statically configured neighbors from the config file into the -RIP neighbor list. If a3RipIpDynNbrCtl has been set to dynamicNbr and the -PORT owner is FR/X.25, no -RIP neighbor can be statically added.")
a3RipIpAggregateCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("aggregate", 1), ("noAggregate", 2))).clone('noAggregate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpAggregateCtl.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: CONTol.')
if mibBuilder.loadTexts: a3RipIpAggregateCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpAggregateCtl.setDescription('This parameter determines if RIP-IP aggregates subnetworks with variable-length subnet masks into one network.')
a3RipIpDeAggregateCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deAggregate", 1), ("noDeAggregate", 2))).clone('noDeAggregate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpDeAggregateCtl.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: CONTol.')
if mibBuilder.loadTexts: a3RipIpDeAggregateCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpDeAggregateCtl.setDescription('This parameter determines if RIP-IP de-aggregate a network into many subnetted network.')
a3RipIpNBMAmodeCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fullMesh", 1), ("nonMesh", 2))).clone('nonMesh')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpNBMAmodeCtl.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: CONTol.')
if mibBuilder.loadTexts: a3RipIpNBMAmodeCtl.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpNBMAmodeCtl.setDescription('This parameter determines if the underlying NBMA network is full-mesh or non-mesh. Partial-mesh is treated as non-mesh. When this object is set to fullMesh(1), RIP-IP advertises routes based on regular split-horizon. If nonMesh(2), RIP-Ip advertises routes based on next-hop split-horizon. This object is only meaningful when the underlying interface is NBMA, (i.e. Frame Relay or X.25)')
a3RipIpExtPolTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 8, 3), )
if mibBuilder.loadTexts: a3RipIpExtPolTable.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: ExteriorPolicy.')
if mibBuilder.loadTexts: a3RipIpExtPolTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpExtPolTable.setDescription('The table contains a list of addresses learned via EGP that are to be included or excluded from RIP reports.')
a3RipIpExtPolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 8, 3, 1), ).setIndexNames((0, "A3COM-RIP-IPEXTNS-R4-MIB", "a3RipIpExtPolPort"), (0, "A3COM-RIP-IPEXTNS-R4-MIB", "a3RipIpExtPolAddr"))
if mibBuilder.loadTexts: a3RipIpExtPolEntry.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: ExteriorPolicy.')
if mibBuilder.loadTexts: a3RipIpExtPolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpExtPolEntry.setDescription('Each entry contains a single IP destination address. This destination is either included or excluded from RIP reports about routes learned via EGP. Each entry also contains a metric to be used in the reports.')
a3RipIpExtPolPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3RipIpExtPolPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpExtPolPort.setDescription('This defines the port to which this entry applies.')
a3RipIpExtPolAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3RipIpExtPolAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpExtPolAddr.setDescription('This specifies a route destination learned via EGP that is to be included or excluded (based on a3RipIpExtPolCtl) from RIP reports.')
a3RipIpExtPolMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpExtPolMetric.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: ExteriorPolicy.')
if mibBuilder.loadTexts: a3RipIpExtPolMetric.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpExtPolMetric.setDescription('The metric that is to be used in RIP reports of this route. If a metric value in the range of 1 to 15 is specified, the route, together with the specified metric, is reported. If the metric 0 is specified, the routing table metric is calculated according to the formula defined in a3RipIpImpMetTable (for either EGP or BGP). (all fractions are rounded down to the next integer)')
a3RipIpExtPolStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 3, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpExtPolStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpExtPolStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB.')
a3RipIpIntPolTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 8, 4), )
if mibBuilder.loadTexts: a3RipIpIntPolTable.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: InteriorPolicy.')
if mibBuilder.loadTexts: a3RipIpIntPolTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpIntPolTable.setDescription('The table contains a list of addresses learned via an IGP other than RIP that are to be included or excluded from RIP reports.')
a3RipIpIntPolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 8, 4, 1), ).setIndexNames((0, "A3COM-RIP-IPEXTNS-R4-MIB", "a3RipIpIntPolPort"), (0, "A3COM-RIP-IPEXTNS-R4-MIB", "a3RipIpIntPolAddr"))
if mibBuilder.loadTexts: a3RipIpIntPolEntry.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: InteriorPolicy.')
if mibBuilder.loadTexts: a3RipIpIntPolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpIntPolEntry.setDescription('Each entry contains a single IP destination address. This destination is either included or excluded from RIP reports. Each entry also contains a metric to be used in the reports.')
a3RipIpIntPolPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3RipIpIntPolPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpIntPolPort.setDescription('This defines the port to which this entry applies.')
a3RipIpIntPolAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3RipIpIntPolAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpIntPolAddr.setDescription('This specifies a route destination learned via an IGP that is to be included or excluded (based on a3RipIpIntPolCtl) from RIP reports.')
a3RipIpIntPolMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpIntPolMetric.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: InteriorPolicy.')
if mibBuilder.loadTexts: a3RipIpIntPolMetric.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpIntPolMetric.setDescription('The metric that is to be used in RIP reports of this route. It a metric value in the range of 1 to 15 is specified, the route, together with the specified metric, is reported. If the metric 0 is specified, the routing table metric is calculated according to the formula defined in a3RipIpImpMetTable (for either OSPF or IISIS). (all fractions are rounded down to the next integer)')
a3RipIpIntPolStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 4, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpIntPolStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpIntPolStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB.')
a3RipIpNetPolTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 8, 5), )
if mibBuilder.loadTexts: a3RipIpNetPolTable.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: NetworkPolicy.')
if mibBuilder.loadTexts: a3RipIpNetPolTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpNetPolTable.setDescription('The table contains a list of addresses that are to be included or excluded from RIP reports. Note, Network Policy overrides Static Policy, Interior Policy, and Exterior Policy in deciding whether a route is to be reported.')
a3RipIpNetPolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 8, 5, 1), ).setIndexNames((0, "A3COM-RIP-IPEXTNS-R4-MIB", "a3RipIpNetPolPort"), (0, "A3COM-RIP-IPEXTNS-R4-MIB", "a3RipIpNetPolAddr"))
if mibBuilder.loadTexts: a3RipIpNetPolEntry.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: NetworkPolicy.')
if mibBuilder.loadTexts: a3RipIpNetPolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpNetPolEntry.setDescription('Each entry contains a single IP destination address. This destination is either included or excluded from RIP reports. Each entry also contains a metric to be used in the reports.')
a3RipIpNetPolPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3RipIpNetPolPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpNetPolPort.setDescription('This defines the port to which this entry applies.')
a3RipIpNetPolAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3RipIpNetPolAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpNetPolAddr.setDescription('This specifies a route destination that is to be included or excluded (based on a3RipIpNetPolCtl) from RIP reports.')
a3RipIpNetPolMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpNetPolMetric.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: NetworkPolicy.')
if mibBuilder.loadTexts: a3RipIpNetPolMetric.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpNetPolMetric.setDescription('The metric that is to be used in RIP reports of this route. If a metric value in the range of 1 to 15 is specified, the route, together with the specified metric, is reported. If the metric 0 is specified, the routing table metric is used.')
a3RipIpNetPolStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 5, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpNetPolStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpNetPolStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB.')
a3RipIpRcvPolTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 8, 6), )
if mibBuilder.loadTexts: a3RipIpRcvPolTable.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: ReceivePolicy.')
if mibBuilder.loadTexts: a3RipIpRcvPolTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpRcvPolTable.setDescription('The table contains a list of addresses learned via trusted neighbors that are to be received and stored in the routing table.')
a3RipIpRcvPolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 8, 6, 1), ).setIndexNames((0, "A3COM-RIP-IPEXTNS-R4-MIB", "a3RipIpRcvPolPort"), (0, "A3COM-RIP-IPEXTNS-R4-MIB", "a3RipIpRcvPolAddr"))
if mibBuilder.loadTexts: a3RipIpRcvPolEntry.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: ReceivePolicy.')
if mibBuilder.loadTexts: a3RipIpRcvPolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpRcvPolEntry.setDescription('Each entry contains a single IP destination address. This destination is either stored or not stored when RIP reports from trusted neighbors are received. Each entry also contains a metric to be used in the routing table entry.')
a3RipIpRcvPolPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3RipIpRcvPolPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpRcvPolPort.setDescription('This defines the port to which this entry applies.')
a3RipIpRcvPolAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3RipIpRcvPolAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpRcvPolAddr.setDescription('This specifies a route destination that is to be stored or not stored (based on a3RipIpRcvPolCtl) when RIP reports from trusted neighbors are received.')
a3RipIpRcvPolMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpRcvPolMetric.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: ReceivePolicy.')
if mibBuilder.loadTexts: a3RipIpRcvPolMetric.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpRcvPolMetric.setDescription('The metric that is to be used in the routing table entry for this route. It a metric value in the range of 1 to 15 is specified, the route, together with the specified metric, is stored. If the metric 0 is specified, the routing report metric is used.')
a3RipIpRcvPolStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 6, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpRcvPolStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpRcvPolStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB.')
a3RipIpStaPolTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 8, 7), )
if mibBuilder.loadTexts: a3RipIpStaPolTable.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: StaticPolicy.')
if mibBuilder.loadTexts: a3RipIpStaPolTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpStaPolTable.setDescription('The table contains a list of static addresses that are to be included or excluded from RIP reports.')
a3RipIpStaPolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 8, 7, 1), ).setIndexNames((0, "A3COM-RIP-IPEXTNS-R4-MIB", "a3RipIpStaPolPort"), (0, "A3COM-RIP-IPEXTNS-R4-MIB", "a3RipIpStaPolAddr"))
if mibBuilder.loadTexts: a3RipIpStaPolEntry.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: StaticPolicy.')
if mibBuilder.loadTexts: a3RipIpStaPolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpStaPolEntry.setDescription('Each entry contains a single IP destination address representing a static route. This destination is either included or excluded from RIP reports. Each entry also contains a metric to be used in the reports.')
a3RipIpStaPolPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3RipIpStaPolPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpStaPolPort.setDescription('This defines the port to which this entry applies.')
a3RipIpStaPolAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 7, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3RipIpStaPolAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpStaPolAddr.setDescription('This specifies a route destination learned statically that is to be included or excluded (based on a3RipIpStaPolCtl) from RIP reports.')
a3RipIpStaPolMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpStaPolMetric.setReference('NETBuilder II Ref. Guide, RIPIP Service Parameter: StaticPolicy.')
if mibBuilder.loadTexts: a3RipIpStaPolMetric.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpStaPolMetric.setDescription('The metric that is to be used in RIP reports of this route. It a metric value in the range of 1 to 15 is specified, the route, together with the specified metric, is reported. If the metric 0 is specified, the routing table metric is calculated according to the formula defined in a3RipIpImpMetTable (for static entries). (all fractions are rounded down to the next integer)')
a3RipIpStaPolStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 7, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpStaPolStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpStaPolStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB.')
a3RipIpNeighborTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 8, 8), )
if mibBuilder.loadTexts: a3RipIpNeighborTable.setReference('NETBuilder II Ref. Guide, RIPIP Service parameters, Neighbor.')
if mibBuilder.loadTexts: a3RipIpNeighborTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpNeighborTable.setDescription('This table contains a list of neighbor addresses that RIP-IP uses to determine to which neighbors it should send update packets. RIP-IP neighbors are router that share a common network and participate in the RIP-IP protocol. Each RIP-IP packet can be either broadcast or addressed individually to each neighbor. If no neighbors are configured on the port, RIP broadcasts update packets on the port.')
a3RipIpNeighborEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 8, 8, 1), ).setIndexNames((0, "A3COM-RIP-IPEXTNS-R4-MIB", "a3RipIpNeighborPort"), (0, "A3COM-RIP-IPEXTNS-R4-MIB", "a3RipIpNeighborAddr"))
if mibBuilder.loadTexts: a3RipIpNeighborEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpNeighborEntry.setDescription("Each entry contains information about a single RIP-IP neighbor. The information include the neighbor's IP address as well as the port from which it can be reached.")
a3RipIpNeighborPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3RipIpNeighborPort.setReference('NETBuilder II Ref. Guide, RIPIP Service parameter: Neighbor.')
if mibBuilder.loadTexts: a3RipIpNeighborPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpNeighborPort.setDescription('This indicates the port from which this neighbor can be reached. The neighbor must be attached to the same network as this port.')
a3RipIpNeighborAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 8, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3RipIpNeighborAddr.setReference('NETBuilder II Ref. Guide, RIPIP Service parameter: Neighbor.')
if mibBuilder.loadTexts: a3RipIpNeighborAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpNeighborAddr.setDescription('This specifies the IP address of the RIP-IP neighbor.')
a3RipIpNeighborStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 8, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpNeighborStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpNeighborStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB.')
a3RipIpTrustedNbrTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 8, 9), )
if mibBuilder.loadTexts: a3RipIpTrustedNbrTable.setReference('NETBuilder II Ref. Guide, RIPIP Service parameter: TrustedNeighbor.')
if mibBuilder.loadTexts: a3RipIpTrustedNbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpTrustedNbrTable.setDescription('This table contains a list of RIP-IP neighbors from which RIP-IP accepts packets. If this table contains no entries for a particular port, RIP-IP will accept all packets from that port.')
a3RipIpTrustedNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 8, 9, 1), ).setIndexNames((0, "A3COM-RIP-IPEXTNS-R4-MIB", "a3RipIpTrustedNbrPort"), (0, "A3COM-RIP-IPEXTNS-R4-MIB", "a3RipIpTrustedNbrAddr"))
if mibBuilder.loadTexts: a3RipIpTrustedNbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpTrustedNbrEntry.setDescription('Each entry identifies a trusted neighbor from which RIP-IP will accept routing packets.')
a3RipIpTrustedNbrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3RipIpTrustedNbrPort.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpTrustedNbrPort.setDescription('This specifies the port for which this table entry applies.')
a3RipIpTrustedNbrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 9, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3RipIpTrustedNbrAddr.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpTrustedNbrAddr.setDescription('This identifies the IP address of a trusted neighbor from which RIP-IP will accept (or not, depending on the value of a3RipIpTrustedNbrCtl) routing packets.')
a3RipIpTrustedNbrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 9, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpTrustedNbrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpTrustedNbrStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB.')
a3RipIpImpMetTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 8, 10), )
if mibBuilder.loadTexts: a3RipIpImpMetTable.setReference('NETBuilder II Ref. Guide, RIPIP Service parameter: ImportMetric.')
if mibBuilder.loadTexts: a3RipIpImpMetTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpImpMetTable.setDescription('This table specifies the operations to be performed on metrics imported from other routing update protocols before they are reported by RIP.')
a3RipIpImpMetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 8, 10, 1), ).setIndexNames((0, "A3COM-RIP-IPEXTNS-R4-MIB", "a3RipIpImpMetProtocol"))
if mibBuilder.loadTexts: a3RipIpImpMetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpImpMetEntry.setDescription('Each entry specifies the operations to be performed on the metric imported from a specific routing update protocol before it is reported by RIP.')
a3RipIpImpMetProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ospf", 1), ("iisis", 2), ("egp", 3), ("bgp", 4), ("static", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3RipIpImpMetProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpImpMetProtocol.setDescription('This object identifies the routing update protocol from which metrics (and routes) are imported.')
a3RipIpImpMetOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("multiply", 1), ("divide", 2))).clone('divide')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpImpMetOperation.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpImpMetOperation.setDescription('This specifies the operation to be performed on the native protocol metric before it is reported by RIP.')
a3RipIpImpMetOperand = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 8, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1073741823))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3RipIpImpMetOperand.setStatus('mandatory')
if mibBuilder.loadTexts: a3RipIpImpMetOperand.setDescription('This specifies the operand of the operation specified by the corresponding instance of a3RipIpImpMetOperation. See the comments describing this table for more details. If this object has the value 0, the default formulas are used. These are ... for OSPF: metric in routing table ----------------------- 4096 for IISIS: metric in routing table ----------------------- 64 for EGP: metric in routing table ----------------------- 16 for BGP: metric in routing table ----------------------- 1024 for static: metric in routing table (unchanged)')
mibBuilder.exportSymbols("A3COM-RIP-IPEXTNS-R4-MIB", a3RipIpExtPolEntry=a3RipIpExtPolEntry, a3RipIpTrustedNbrStatus=a3RipIpTrustedNbrStatus, a3RipIpNeighborAddr=a3RipIpNeighborAddr, a3RipIpTrustedNbrPort=a3RipIpTrustedNbrPort, a3RipIpNetPolCtl=a3RipIpNetPolCtl, a3RipIpIntPolMetric=a3RipIpIntPolMetric, a3RipIpTrustedNbrTable=a3RipIpTrustedNbrTable, a3RipIpExtPolAllMet=a3RipIpExtPolAllMet, a3RipIpRcvPolTable=a3RipIpRcvPolTable, a3RipIpBcastCtl=a3RipIpBcastCtl, brouterMIB=brouterMIB, a3RipIpTrustedNbrCtl=a3RipIpTrustedNbrCtl, a3RipIpExtPolPort=a3RipIpExtPolPort, a3RipIpIntPolTable=a3RipIpIntPolTable, a3RipIpNetPolAllMet=a3RipIpNetPolAllMet, a3RipIpStaPolEntry=a3RipIpStaPolEntry, a3RipIpIntPolEntry=a3RipIpIntPolEntry, a3RipIpUnnAdvCtl=a3RipIpUnnAdvCtl, a3RipIpStaPolTable=a3RipIpStaPolTable, a3RipIpStaPolPort=a3RipIpStaPolPort, a3RipIpImpMetProtocol=a3RipIpImpMetProtocol, a3RipIpDefMetric=a3RipIpDefMetric, a3RipIpNeighborStatus=a3RipIpNeighborStatus, a3RipIpUpdateTime=a3RipIpUpdateTime, a3RipIpTriggerCtl=a3RipIpTriggerCtl, a3RipIpNetPolMetric=a3RipIpNetPolMetric, a3RipIpNeighborEntry=a3RipIpNeighborEntry, a3RipIpImpMetOperand=a3RipIpImpMetOperand, a3RipIpRcvPolAddr=a3RipIpRcvPolAddr, RowStatus=RowStatus, a3RipIpListenCtl=a3RipIpListenCtl, a3RipIpStaPolCtl=a3RipIpStaPolCtl, a3RipIpCtlEntry=a3RipIpCtlEntry, a3RipIpAggregateCtl=a3RipIpAggregateCtl, a3RipIpExtPolStatus=a3RipIpExtPolStatus, a3RipIpRcvPolPort=a3RipIpRcvPolPort, a3RipIpIntPolCtl=a3RipIpIntPolCtl, a3RipIpRcvPolMetric=a3RipIpRcvPolMetric, a3RipIpStaPolStatus=a3RipIpStaPolStatus, a3RipIpIntPolAddr=a3RipIpIntPolAddr, a3RipIpNeighborPort=a3RipIpNeighborPort, a3RipIpImpMetEntry=a3RipIpImpMetEntry, a3ComRipIp=a3ComRipIp, a3RipIpTalkCtl=a3RipIpTalkCtl, a3RipIpExtPolCtl=a3RipIpExtPolCtl, a3RipIpStaPolAllMet=a3RipIpStaPolAllMet, a3RipIpNeighborTable=a3RipIpNeighborTable, a3RipIpTrustedNbrAddr=a3RipIpTrustedNbrAddr, a3RipIpImpMetOperation=a3RipIpImpMetOperation, a3RipIpExtPolAddr=a3RipIpExtPolAddr, a3RipIpExtPolTable=a3RipIpExtPolTable, a3RipIpRcvPolStatus=a3RipIpRcvPolStatus, a3RipIpNetPolStatus=a3RipIpNetPolStatus, a3RipIpRcvPolCtl=a3RipIpRcvPolCtl, a3RipIpPortIndex=a3RipIpPortIndex, a3RipIpIntPolStatus=a3RipIpIntPolStatus, a3RipIpCtlTable=a3RipIpCtlTable, a3RipIpNetPolPort=a3RipIpNetPolPort, a3RipIpTrustedNbrEntry=a3RipIpTrustedNbrEntry, a3RipIpDeAggregateCtl=a3RipIpDeAggregateCtl, a3RipIpRcvPolAllMet=a3RipIpRcvPolAllMet, a3RipIpDynNbrCtl=a3RipIpDynNbrCtl, a3RipIpImpMetTable=a3RipIpImpMetTable, a3RipIpNBMAmodeCtl=a3RipIpNBMAmodeCtl, a3RipIpNetPolEntry=a3RipIpNetPolEntry, a3Com=a3Com, a3RipIpStaPolAddr=a3RipIpStaPolAddr, a3RipIpStaPolMetric=a3RipIpStaPolMetric, a3RipIpNetPolTable=a3RipIpNetPolTable, a3RipIpIntPolPort=a3RipIpIntPolPort, a3RipIpIntPolAllMet=a3RipIpIntPolAllMet, a3RipIpRcvPolEntry=a3RipIpRcvPolEntry, a3RipIpNetPolAddr=a3RipIpNetPolAddr, a3RipIpPoisonCtl=a3RipIpPoisonCtl, a3RipIpExtPolMetric=a3RipIpExtPolMetric)
