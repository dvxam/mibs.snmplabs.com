#
# PySNMP MIB module FIBRONICS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/tin/Dev/mibs.snmplabs.com/asn1/FIBRONICS-MIB
# Produced by pysmi-0.3.4 at Fri Jan 31 21:33:37 2020
# On host bier platform Linux version 5.4.0-3-amd64 by user tin
# Using Python version 3.7.6 (default, Jan 19 2020, 22:34:52) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, Integer32, ObjectIdentity, Gauge32, TimeTicks, ModuleIdentity, Unsigned32, Counter32, iso, MibIdentifier, IpAddress, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, enterprises, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Integer32", "ObjectIdentity", "Gauge32", "TimeTicks", "ModuleIdentity", "Unsigned32", "Counter32", "iso", "MibIdentifier", "IpAddress", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "enterprises", "NotificationType")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
fibronics = MibIdentifier((1, 3, 6, 1, 4, 1, 22))
fbr101 = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101))
fbr2 = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2))
fbrStack = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2))
chassis = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7))
genGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8))
genPort = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 9))
genIntPort = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 10))
softRedundancy = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 11))
eth = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12))
tok = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13))
ts = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 14))
ltalk = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 15))
cl = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 16))
fbrOID = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 17))
fbrSecurity = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 18))
fbrLanSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19))
deviceMgr = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 20))
bRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21))
probe = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 22))
chHWType = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 255))).clone(namedValues=NamedValues(("let18", 1), ("let3", 2), ("let36", 3), ("let18Extended", 4), ("lert40", 5), ("let10", 6), ("fdx100", 7), ("stack", 8), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chHWType.setStatus('mandatory')
if mibBuilder.loadTexts: chHWType.setDescription('Indicates type of enclosure in which the FIBRONICS SNMP agent operates.')
chNumberOfSlots = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chNumberOfSlots.setStatus('mandatory')
if mibBuilder.loadTexts: chNumberOfSlots.setDescription('Number of manageable slots in the chassis. In FIBRONICS implementation it describes the number of manageable slots in the chassis (not all slots should be occuppied).')
chNumberOfEthernetBuses = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chNumberOfEthernetBuses.setStatus('mandatory')
if mibBuilder.loadTexts: chNumberOfEthernetBuses.setDescription('Indicates the number of internal Ethernet buses provided by the box.')
chNumberOfTRBuses = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chNumberOfTRBuses.setStatus('mandatory')
if mibBuilder.loadTexts: chNumberOfTRBuses.setDescription('Indicates the number of internal Token Ring buses provided by the box.')
chNumberOfFDDIBuses = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chNumberOfFDDIBuses.setStatus('mandatory')
if mibBuilder.loadTexts: chNumberOfFDDIBuses.setDescription('Indicates the number of internal FDDI buses provided by the box.')
chNumberOfLocalTalkBuses = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chNumberOfLocalTalkBuses.setStatus('mandatory')
if mibBuilder.loadTexts: chNumberOfLocalTalkBuses.setDescription('Indicates the number of internal Local Talk buses provided by the box.')
chReset = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chReset.setStatus('mandatory')
if mibBuilder.loadTexts: chReset.setDescription('Setting the value of this attribute to ON is interpreted as a reset command for the whole chassis. It initiates a complete reinitialisation of the chassis and of all the devices incorporated inside the chassis.')
chFullConfig = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFullConfig.setStatus('mandatory')
if mibBuilder.loadTexts: chFullConfig.setDescription('Full configuration message retrieved by FIBRONICS management stations at periodic interrogation times. Coded in compact internal FIBRONICS application format.')
chAg = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9))
chGenAgTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 1), )
if mibBuilder.loadTexts: chGenAgTable.setStatus('mandatory')
if mibBuilder.loadTexts: chGenAgTable.setDescription('Table of configuration attributes common to all SNMP agents in FIBRONICS hubs.')
chGenAgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "chGenAgId"))
if mibBuilder.loadTexts: chGenAgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chGenAgEntry.setDescription('An entry in the table, containing configuration attributes for a single agent.')
chGenAgId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chGenAgId.setStatus('mandatory')
if mibBuilder.loadTexts: chGenAgId.setDescription('Agent index for identifying the agent.Takes the value of the slot number where the agent card is inserted. For box agents the value of chGenAgId is chNumberOfSlots+1.')
chGenAgType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 255))).clone(namedValues=NamedValues(("nma1-et", 1), ("nma1-et-e", 2), ("nma1-tr", 3), ("nma2-et", 4), ("nma2-tr", 5), ("nma2-fddi", 6), ("ielb", 7), ("itlb", 8), ("lts16", 9), ("ierp", 10), ("iefn", 11), ("itfn", 12), ("nm2069", 13), ("nma-rt", 14), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chGenAgType.setStatus('mandatory')
if mibBuilder.loadTexts: chGenAgType.setDescription('Agent type.')
chGenAgMgmtIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 255))).clone(namedValues=NamedValues(("none", 1), ("regular1822", 2), ("hdh1822", 3), ("ddn-x25", 4), ("rfc877-x25", 5), ("ethernet-csmacd", 6), ("iso88023-csmacd", 7), ("iso88024-tokenBus", 8), ("iso88025-tokenRing", 9), ("iso88026-man", 10), ("starLan", 11), ("proteon-10MBit", 12), ("proteon-80MBit", 13), ("hyperchannel", 14), ("fddi", 15), ("lapb", 16), ("sdlc", 17), ("t1-carrier", 18), ("cept", 19), ("basicIsdn", 20), ("primaryIsdn", 21), ("propPointToPointSerial", 22), ("ppp", 23), ("softwareLoopback", 24), ("eon", 25), ("ethernet-3Mbit", 26), ("nsip", 27), ("slip", 28), ("ip", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chGenAgMgmtIfType.setStatus('mandatory')
if mibBuilder.loadTexts: chGenAgMgmtIfType.setDescription("This attribute describes one of the interfaces of agents existing on FIBRONICS modules and their type. Value 'none' defines the lack of an interface recognized by the management console. Any other value defines an interface whose type is recognized by the management console and may be used as a management channel.")
chGenAgAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chGenAgAddr.setStatus('mandatory')
if mibBuilder.loadTexts: chGenAgAddr.setDescription('This attribute defines an unique address by which the agent may be addressed by the management console. The address format should be consistent with the type defined by chGenAgMgmtIfType.')
chGenAgSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 1, 1, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chGenAgSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: chGenAgSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
chFbrAgTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2), )
if mibBuilder.loadTexts: chFbrAgTable.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgTable.setDescription('Table of configuration attributes of FIBRONICS SNMP box agents in FIBRONICS hubs.')
chFbrAgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1), ).setIndexNames((0, "FIBRONICS-MIB", "chFbrAgId"))
if mibBuilder.loadTexts: chFbrAgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgEntry.setDescription('An entry in the table, containing configuration attributes for a single agent.')
chFbrAgId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgId.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgId.setDescription('Agent index for identifying the agent. Identical to the index in chGenAgTable for the described agent.')
chFbrAgSLIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgSLIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgSLIPAddress.setDescription('IP address of the SLIP channel of the agent')
chFbrAgSWVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgSWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgSWVersion.setDescription('ASCII string for description and display of the agent software version.')
chFbrAgKernelVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgKernelVersion.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgKernelVersion.setDescription('ASCII string for description and display of the agent operating system (kernel) version.')
chFbrAgCoprocSWVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgCoprocSWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgCoprocSWVersion.setDescription("ASCII string describing the software version of the agent's coprocessor.")
chFbrAgSWFault = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgSWFault.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgSWFault.setDescription('System fault emitted by agent software. It covers faults detected by the agent operating system and drivers. EnterpriseSpecific traps mechanism is used for transfering these traps to the management system.')
chFbrAgMgmtBusSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgMgmtBusSelection.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgMgmtBusSelection.setDescription('Attribute describing the number of the bus on which management data are reported.')
chFbrAgCoprocCommStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("commProblems", 2), ("timeout", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgCoprocCommStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgCoprocCommStatus.setDescription('Attribute describing the status of the communication between the agent and its coprocessor.')
chFbrAgCommDebugMode = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgCommDebugMode.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgCommDebugMode.setDescription("Attribute describing the agent mode in which communication problem traps are sent to managers (value 'on') or are not sent to managers (value 'off').")
chFbrAgConfigChangeTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgConfigChangeTraps.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgConfigChangeTraps.setDescription('The value of this attributes determines whether or not the agent sends Configuration Change traps to the manager.')
chFbrAgFaultTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgFaultTraps.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgFaultTraps.setDescription('The value of this attributes determines whether or not the agent sends Fault traps to the manager.')
chFbrAgTrafficThreshTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgTrafficThreshTraps.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgTrafficThreshTraps.setDescription('The value of this attributes determines whether or not the agent sends Traffic Threshold traps to the manager.')
chFbrAgGroupEnrollDeenrollTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgGroupEnrollDeenrollTraps.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgGroupEnrollDeenrollTraps.setDescription('The value of this attributes determines whether or not the agent sends Group Enrollment and Group Deenrollment traps to the manager.')
chFbrAgSoftFaultTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgSoftFaultTraps.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgSoftFaultTraps.setDescription('The value of this attributes determines whether or not the agent sends Software Fault traps to the manager.')
chFbrAgHubEnrollTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgHubEnrollTraps.setStatus('obsolete')
if mibBuilder.loadTexts: chFbrAgHubEnrollTraps.setDescription('The value of this attributes determines whether or not the agent sends periodic Hub Enrollment traps to the manager.')
chFbrAgTempThreshTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgTempThreshTraps.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgTempThreshTraps.setDescription('The value of this attributes determines whether or not the agent sends Temperature Threshold traps to the manager.')
chFbrAgSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 17), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
chFbrAgLastAddrConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 18), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgLastAddrConfig.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgLastAddrConfig.setDescription('Configuration attribute describing the last physical address detected at each port. Coded in internal FIBRONICS application format. ')
chFbrAgSecAddrConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 19), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgSecAddrConfig.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgSecAddrConfig.setDescription('Configuration attribute describing the configuration of the secure addresses. Coded in internal FIBRONICS application format. ')
chFbrAgSoftwareStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unLoadable", 1), ("loaded", 2), ("downLoading", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgSoftwareStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgSoftwareStatus.setDescription('Describes configuration of the firmware on this agent. unLoadable(1) - is returned by agents which do not support the Software Download feature; loaded(2) - is returned by agents with loaded software; downLoading(3) - when the attribute is set to this value by manager, it triggers the Software Download procedure. When procedure finished, agent software will restablish value loaded(2).')
chFbrAgConfigurationSymbol = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgConfigurationSymbol.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgConfigurationSymbol.setDescription("Defines the Configuration Symbol attached to any hardware module manufactured by FIBRONICS. One single character A..Z defines the CS version. For older modules which did not support this option on SNMP character '*' will be returned.")
chFbrAgIntTemp = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgIntTemp.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgIntTemp.setDescription('Internal temperature measured by the temperature sensor placed on the agent card. Expressed in Celsius degrees.')
chFbrAgBootVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 23), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgBootVersion.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgBootVersion.setDescription('ASCII string for description and display of the agent boot software version.')
chFbrAgSensorFault = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgSensorFault.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgSensorFault.setDescription('A code of a sensor fault discovered by the agent.')
chFbrAgSensorFaultTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgSensorFaultTraps.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgSensorFaultTraps.setDescription('This attribute enables/disables generation of the sensor fault trap.')
chFbrAgInterProcFault = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgInterProcFault.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgInterProcFault.setDescription('A code of intercommunication fault between Main - Master processors.')
chFbrAgInterProcFaultTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 2, 1, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgInterProcFaultTraps.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgInterProcFaultTraps.setDescription('This attribute enables/disables generation of the intercommunication fault trap.')
chFbrAgSetup = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 3))
chFbrAgMaxNmbOfMngrs = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgMaxNmbOfMngrs.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgMaxNmbOfMngrs.setDescription('Maximum number of permanent managers.')
chFbrAgPermMngrTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 3, 2), )
if mibBuilder.loadTexts: chFbrAgPermMngrTable.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgPermMngrTable.setDescription('Table of permanent managers.')
chFbrAgPermMngrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 3, 2, 1), ).setIndexNames((0, "FIBRONICS-MIB", "chFbrAgPermMngrId"))
if mibBuilder.loadTexts: chFbrAgPermMngrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgPermMngrEntry.setDescription('An entry in the permanent managers table.')
chFbrAgPermMngrId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgPermMngrId.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgPermMngrId.setDescription('Index in the permanent managers table. It ranges from 1 to chFbrAgMaxNmbOfMngrs')
chFbrAgPermMngrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 3, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgPermMngrAddr.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgPermMngrAddr.setDescription('IP address of a permanent manager.')
chFbrAgMaxNmbOfNets = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgMaxNmbOfNets.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgMaxNmbOfNets.setDescription('Maximum number of remote networks.')
chFbrAgRmtNetTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 3, 4), )
if mibBuilder.loadTexts: chFbrAgRmtNetTable.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgRmtNetTable.setDescription('Remote networks table.')
chFbrAgRmtNetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 3, 4, 1), ).setIndexNames((0, "FIBRONICS-MIB", "chFbrAgRmtNetId"))
if mibBuilder.loadTexts: chFbrAgRmtNetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgRmtNetEntry.setDescription('Entry in the remote networks table.')
chFbrAgRmtNetId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chFbrAgRmtNetId.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgRmtNetId.setDescription('Index of a remote network. It ranges from 1 to chFbrAgMaxNmbOfNets.')
chFbrAgRmtNetAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 3, 4, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgRmtNetAddr.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgRmtNetAddr.setDescription('Address of a remote network. The host portion is always 0.')
chFbrAgRmtNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 3, 4, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgRmtNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgRmtNetMask.setDescription('Subnet mask for the remote network.')
chFbrAgDateTime = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 3, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgDateTime.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgDateTime.setDescription('Current date and time for NMA-TR. The format is YYMMDDhhmmssw, where w - day of the week e.g., 1=Mon, 2=Tue,..., 7=Sun.')
chFbrAgReset = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 9, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chFbrAgReset.setStatus('mandatory')
if mibBuilder.loadTexts: chFbrAgReset.setDescription('This attribute enables the user to reset the agent.')
chMgr = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 10))
chMgrTrapRepStatus = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chMgrTrapRepStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chMgrTrapRepStatus.setDescription("Value 'on' indicates that SNMP agent should send SNMP traps (traffic ex- cluded) to the manager.")
chMgrContPerfRep = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 10, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chMgrContPerfRep.setStatus('mandatory')
if mibBuilder.loadTexts: chMgrContPerfRep.setDescription("Value 'on' indicates that the SNMP agent should send traffic SNMP traps to the manager.")
chMgrMngmtState = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 10, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chMgrMngmtState.setStatus('mandatory')
if mibBuilder.loadTexts: chMgrMngmtState.setDescription("Attribute to be set by manager in order to instruct the agent to enter into a management session with the console. Setting this value to 'on' has the effect of performing an 'I am your manager' action upon the agent.")
chMgrPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 10, 4), Integer32().clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chMgrPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: chMgrPollInterval.setDescription("The attribute defines an interval during which the agent is waiting for the manager's requests. Default value 5 minutes.")
chHW = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 11))
chHWPSUTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 11, 1), )
if mibBuilder.loadTexts: chHWPSUTable.setStatus('mandatory')
if mibBuilder.loadTexts: chHWPSUTable.setDescription('Table of configuration attributes for Power Supply Units. This table can be retrieved only from agents equipped with adequate hardware.')
chHWPSUEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 11, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "chHWPSUId"))
if mibBuilder.loadTexts: chHWPSUEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chHWPSUEntry.setDescription('An entry in the table, containing configuration attributes for a single Power Supply Unit.')
chHWPSUId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chHWPSUId.setStatus('mandatory')
if mibBuilder.loadTexts: chHWPSUId.setDescription('PSU index for identifying the PSU.')
chHWPSUActivityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notActive", 1), ("dormant", 2), ("active", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chHWPSUActivityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: chHWPSUActivityStatus.setDescription('This attribute defines the status of the PSU in what concerns supplying power to the chassis. NotActive - indicates a disabled or defective PSU which cannot supply power to the chassis. Dormant - indicates a functional PSU which is installed for backup purposes and can at any moment supply power to the devices in the chassis. Active - indicates that the PSU supplies power to the chassis.')
chHWPSULocation = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("internal", 2), ("external", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chHWPSULocation.setStatus('mandatory')
if mibBuilder.loadTexts: chHWPSULocation.setDescription('Describes the location (internal or external) of the PSU.')
chHWPSUVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 11, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chHWPSUVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: chHWPSUVoltage.setDescription('Indicates voltage of PSU expressed in miliVolts.')
chHWIntTempWarning = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 11, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("exceeded", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chHWIntTempWarning.setStatus('mandatory')
if mibBuilder.loadTexts: chHWIntTempWarning.setDescription('Fault condition indicating that the temperature measured by one of the sensors internal to the box exceeded chHWIntTempThresh.')
chHWIntTempThresh = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 11, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chHWIntTempThresh.setStatus('mandatory')
if mibBuilder.loadTexts: chHWIntTempThresh.setDescription('Internal enclosure temperature threshold value, expressed in degrees Celsius. When exceeded, a trap is sent to the management console. ')
chHWPeakIntTemp = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 11, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chHWPeakIntTemp.setStatus('mandatory')
if mibBuilder.loadTexts: chHWPeakIntTemp.setDescription('Maximum internal temperature inside the chassis. It is the maximum of the temperature values detected by different temperature sensors inside the box. ')
chSlotLastChange = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 7, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chSlotLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: chSlotLastChange.setDescription('This attribute contains the value of sysUpTime at the time any of the modules in the hub was enrolled/deenrolled.')
genGroupTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1), )
if mibBuilder.loadTexts: genGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupTable.setDescription('Table of configuration attributes for managed FIBRONICS modules. Includes configuration data which are independent of the specific functionality of the module.')
genGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "genGroupId"))
if mibBuilder.loadTexts: genGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupEntry.setDescription('An entry in the table, containing data about a single group.')
genGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupId.setDescription('Index which identifies the group inside the chassis for which this entry contains information. Equals the number of the slot by which the group is accessed. This value is never greater than chNumberOfSlots.')
genGroupSWVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupSWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupSWVersion.setDescription('ASCII string for description and display of the group software version.')
genGroupKernelVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupKernelVersion.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupKernelVersion.setDescription('ASCII string for description and display of the group kernel version.')
genGroupType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 255))).clone(namedValues=NamedValues(("le10b", 1), ("le10b-2", 2), ("le10c", 3), ("le10c-2", 4), ("le15", 5), ("le15-2", 6), ("le20", 7), ("le30x", 8), ("le30x-2", 9), ("le30xd", 10), ("le40x", 11), ("le40xt", 12), ("ltr4-RJ45", 13), ("ltr4-D9", 14), ("ltr4-D25", 15), ("ltr4-FO", 16), ("ltrio-RJ45", 19), ("ltrio-D9", 20), ("ltrio-D25", 21), ("ltrio-FO", 22), ("ltrio-Con1", 23), ("ltrio-Con2", 24), ("le10b-2r", 25), ("le10c-2r", 26), ("le80xt", 27), ("le140xt", 28), ("ielb", 29), ("ltrf4", 30), ("ltrf16", 31), ("lts16", 32), ("le20n", 33), ("ltr104-RJ45", 34), ("le20r", 35), ("llt8", 36), ("le20s", 37), ("le10b2n", 38), ("ltr104-D9", 39), ("ltr104-D25", 40), ("ltrt-RJ45", 41), ("ltrt-D9", 42), ("ltr104f", 43), ("itlb", 44), ("le140xtf", 45), ("le120r", 46), ("le120r-2", 47), ("le140xtc", 48), ("le110b", 49), ("le110bq", 50), ("lcl100", 51), ("le140xtq", 52), ("le20n-fb", 53), ("le20s-fb", 54), ("le140xtf-fb", 55), ("ltr104s", 56), ("lert40-AUI", 57), ("lert40-10BASET", 58), ("lfd104-mic", 59), ("lfd104-stm", 60), ("lfd104-stl", 61), ("lfd104-stp", 62), ("lfd104-utp", 63), ("lfd102-mic", 64), ("lfd102-stm", 65), ("lfd102-sts", 66), ("le140xtn", 67), ("ltr104a", 68), ("le120q", 69), ("le120sq2", 70), ("le120sq5", 71), ("le120q-fb", 72), ("le120sq2-fb", 73), ("le120sq5-fb", 74), ("ltr108t", 75), ("ltr108f", 76), ("lse808", 77), ("lhs", 78), ("ierb", 79), ("iefn", 80), ("itfn", 81), ("itre1", 82), ("istc1", 83), ("iftc", 84), ("ietlb", 85), ("ierp", 86), ("lse108", 87), ("lse208", 88), ("le110cq", 89), ("itre2", 90), ("istc2", 91), ("fer2061", 92), ("le115q", 93), ("sh-t16", 94), ("sh-e8", 95), ("lhb", 96), ("sh-efn", 97), ("sh-tfn", 98), ("itng", 99), ("lace100", 100), ("le140xts", 101), ("le40xtn", 102), ("le80xtn", 103), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupType.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupType.setDescription('Attribute describing the type of FIBRONICS Ethernet group.')
genGroupDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupDescr.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupDescr.setDescription('Descriptor of the group in ASCII (readable) format, mainly for use with generic management applications.')
genGroupNumberOfPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupNumberOfPorts.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupNumberOfPorts.setDescription('Number of ports in group. It is assumed that on each group the ports are assigned unique numbers in the range from 1 to genGroupNumberOfPorts. They correspond to the number of ports on the module (FRU)')
genGroupNumberOfIntPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupNumberOfIntPorts.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupNumberOfIntPorts.setDescription('Number of internal ports (ports connected to the chassis buses) on the module.')
genGroupReset = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genGroupReset.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupReset.setDescription("Setting the value of this attribute to 'on' is interpreted as a software RESET command. Sensor software is reinitialized and according to the sensor specifications, partial or total reset of the module hardware may be performed.")
genGroupAutoMan = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("auto", 1), ("man", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupAutoMan.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupAutoMan.setDescription('This attribute reflects the status of the Auto/Manual switch which defines the working mode of FIBRONICS sensors. In the MANUAL mode no set operations may be performed on attributes related to the sensor. The sensor works according to configuration switches set by hardware and transmits all configuration information to the agent. In the AUTO mode, hardware switches are overridden by set commands.')
genGroupFullConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupFullConfig.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupFullConfig.setDescription('Attribute describing the full configuration of a group in internal FIBRONICS application format.')
genGroupRedun12 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genGroupRedun12.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupRedun12.setDescription('Value ON of this attribute defines a redundancy (backup) relationship between synchronous external ports 1 and 2 on a FIBRONICS module.')
genGroupRedun34 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genGroupRedun34.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupRedun34.setDescription('Value ON of this attribute defines a redundancy (backup) relationship between synchronous external ports 3 and 4 on a FIBRONICS module.')
genGroupRedun13_14 = MibScalar((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setLabel("genGroupRedun13-14").setMaxAccess("readwrite")
if mibBuilder.loadTexts: genGroupRedun13_14.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupRedun13_14.setDescription('Value ON of this attribute defines a redundancy (backup) relationship between synchronous external ports 13 and 14 on a FIBRONICS module.')
genGroupStandAloneMode = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genGroupStandAloneMode.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupStandAloneMode.setDescription("Value ON of this attribute indicates the sensor's operation Stand Alone mode . Internal ports are disabled and the card functions in a local star configuration toward its external ports.")
genGroupInterProcCommStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("ok", 1), ("commProblems", 2), ("noCommunication", 3), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupInterProcCommStatus.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupInterProcCommStatus.setDescription('This attribute describes the status of the communication between the microprocessor of the sensor and the microprocessor of the agent on cards with embedded agents.')
genGroupCommStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("ok", 1), ("commProblems", 2), ("noCommunication", 3), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupCommStatus.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupCommStatus.setDescription('This attribute describes the communication status of the group with the SNMP Agent as detected and reported by the agent.')
genGroupHWStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("ok", 1), ("hardwareProblems", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupHWStatus.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupHWStatus.setDescription('This attribute describes the status of the group hardware as detected by the sensors software.')
genGroupSupplyVoltageFault = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupSupplyVoltageFault.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupSupplyVoltageFault.setDescription("A value 'on' of this attribute informs of a 'voltage supply out-of-range' error condition on sensor equipped with hardware which checks this condition.")
genGroupIntTemp = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupIntTemp.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupIntTemp.setDescription('Internal temperature of the enclosure as measured by the specific module instance.')
genGroupSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 20), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
genGroupConfigurationSymbol = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genGroupConfigurationSymbol.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupConfigurationSymbol.setDescription("Defines the Configuration Symbol attached to any hardware module manufactured by FIBRONICS. One single character A..Z defines the CS version. For older modules which did not support this option on SNMP character '*' will be returned.")
genGroupLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 8, 1, 1, 22), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupLastChange.setDescription('This attribute contains the value of sysUpTime at the time any change pertaining to the specified group occurred.')
genPortTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 9, 1), )
if mibBuilder.loadTexts: genPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: genPortTable.setDescription('Table of configuration attributes for managed FIBRONICS ports. Includes configuration data which are independent of the specific functionality of the port.')
genPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 9, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "genPortGroupId"), (0, "FIBRONICS-MIB", "genPortId"))
if mibBuilder.loadTexts: genPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: genPortEntry.setDescription('An entry in the table, containing data about a single port.')
genPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: genPortGroupId.setDescription('Index which identifies the group inside the chassis for which this entry contains information. Equals the number of the slot by which the group containing the port is accessed. This value is never greater than chNumberOfSlots.')
genPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genPortId.setStatus('mandatory')
if mibBuilder.loadTexts: genPortId.setDescription('Index which identifies the port inside the group for which this entry contains information. It generally corresponds with the number by which the port is identified and is marked on the module. This value is never greater than genGroupNumberOfPorts of the group to which the port belongs.')
genPortFunctionality = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25))).clone(namedValues=NamedValues(("private", 1), ("repeaterAUI", 2), ("repeaterThin", 3), ("repeater10BaseT", 4), ("tenBaseFSyncAct", 5), ("foirl", 6), ("xcvr", 7), ("lobe", 8), ("ri", 9), ("ro", 10), ("serial", 11), ("localTalk", 12), ("fddi", 13), ("clock", 14), ("genTokenRing", 15), ("dte", 16), ("activeLobe", 17), ("genActiveTokenRing", 18), ("tenBaseFB", 19), ("lse10BaseT", 20), ("lhsFiber", 21), ("wan", 22), ("star", 23), ("activeRI", 24), ("activeRO", 25)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genPortFunctionality.setStatus('mandatory')
if mibBuilder.loadTexts: genPortFunctionality.setDescription('Describes the functionality of the port according to international standards.')
genPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 255))).clone(namedValues=NamedValues(("le10bPort", 1), ("le10cPort", 2), ("le15Port", 3), ("le20Port", 4), ("le30xPort", 5), ("le30xdPort", 6), ("le40xPort", 7), ("le40xtPort", 8), ("lobeRJ45", 9), ("lobeD9", 10), ("lobeD25", 11), ("lobeFO", 12), ("ri104D25", 13), ("ro104D25", 14), ("riRJ45", 15), ("riD9", 16), ("riD25", 17), ("riFO", 18), ("ri104RJ45", 19), ("ri104D9", 20), ("roRJ45", 21), ("roD9", 22), ("roD25", 23), ("roFO", 24), ("ro104RJ45", 25), ("ro104D9", 26), ("le80xtPort", 27), ("le140xtPort", 28), ("ielb-AUIPort", 29), ("ielb-10btPort", 30), ("ltrf4Port", 31), ("ltrf16Port", 32), ("lts16Port", 33), ("llt8Port", 34), ("le20rPort", 35), ("itlbRoPort", 36), ("itlbRiPort", 37), ("itlbDTEPort", 38), ("starFO", 39), ("le10bnPort", 40), ("le120rPort", 41), ("le140xtf-foPort", 42), ("le140xtf-10btPort", 43), ("le140xtcPort", 44), ("le110bPort", 45), ("le110bqPort", 46), ("le140xtqPort", 47), ("lert40-AUIPort", 48), ("lert40-10btPort", 49), ("clock-int", 50), ("clock-ext", 51), ("ri104RJ45S", 52), ("r0104RJ45S", 53), ("lobe104RJ45S", 54), ("le20fbPort", 55), ("le140xtf-fofbPort", 56), ("fddi-micPort1", 57), ("fddi-micPort2", 58), ("fddi-micPort3", 59), ("fddi-stmPort1", 60), ("fddi-stmPort2", 61), ("fddi-stmPort3", 62), ("fddi-stlPort1", 63), ("fddi-stlPort2", 64), ("fddi-stlPort3", 65), ("fddi-stpPort1", 66), ("fddi-stpPort2", 67), ("fddi-stpPort3", 68), ("fddi-utpPort1", 69), ("fddi-utpPort2", 70), ("fddi-utpPort3", 71), ("fddi-stsPort1", 72), ("fddi-stsPort2", 73), ("fddi-stsPort3", 74), ("le140xtnPort", 75), ("ltr104a-lobePort", 76), ("ltr104a-riPort", 77), ("ltr104a-roPort", 78), ("le120qPort", 79), ("le120sq2PortS", 80), ("le120sq2PortM", 81), ("le120sq5Port", 82), ("le120q-fbPort", 83), ("le120sq2-fbPortS", 84), ("le120sq2-fbPortM", 85), ("le120sq5-fbPort", 86), ("ltr108t-lobePort1", 87), ("ltr108t-riPort1", 88), ("ltr108t-roPort1", 89), ("ltr108t-lobePort", 90), ("ltr108f-lobePort", 91), ("ltr108f-starPortFO", 92), ("ltr108f-riPortFO", 93), ("ltr108f-roPortFO", 94), ("lse808Port", 95), ("lhsPort", 96), ("ierbPort", 97), ("iefnPort", 98), ("itfnPort", 99), ("itrePort", 100), ("istcPort", 101), ("iftcPort", 102), ("ietlb-lobePort", 103), ("ietlb-riPort", 104), ("ietlb-roPort", 105), ("ietlb-10BaseTPort", 106), ("ierpPort", 107), ("lse108Port", 108), ("lse208Port", 109), ("le110cqPort", 110), ("ltr108t-starPort1", 111), ("fer2061-10btPort", 112), ("fer2061-AUIPort", 113), ("fer2061-FOPort", 114), ("fer2061-FOSyncPort", 115), ("le115qPort", 116), ("sht-lobePort", 117), ("sht-riRJ45Port", 118), ("sht-riD9Port", 119), ("sht-riFOPort", 120), ("sht-roRJ45Port", 121), ("sht-roD9Port", 122), ("sht-roFOPort", 123), ("lhbPort", 124), ("itngPort", 125), ("le140xtsPort", 126), ("le40xtnPort", 127), ("le80xtnPort", 128), ("unknownPort", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genPortType.setStatus('mandatory')
if mibBuilder.loadTexts: genPortType.setDescription('Attribute describing the type of FIBRONICS port.')
genPortDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 9, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genPortDescr.setStatus('mandatory')
if mibBuilder.loadTexts: genPortDescr.setDescription('Descriptor of the port in ASCII (readable) format, mainly for use with generic management applications.')
genPortActivityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 9, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("notActive", 1), ("dormant", 2), ("active", 3), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genPortActivityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: genPortActivityStatus.setDescription('This attribute defines the status of ports that may be part of a redundancy scheme. NotActive - indicates a disabled port which cannot transmit or receive packets even if included in a redundancy scheme. Dormant - indicates an enabled port which does not transmit or receive packets, but because it is included in a redundancy scheme, it may at any moment become responsible packet transmission and reception. Active - indicates that the port transmits and receives packets, serving as the main path in the redundant configuration.')
genPortSecurityPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 9, 1, 1, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genPortSecurityPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: genPortSecurityPolicy.setDescription('Security policy (Trap Only or Trap and Close) assigned to this port. The information is coded in internal FIBRONICS format.')
genPortSecureAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 9, 1, 1, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genPortSecureAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: genPortSecureAddresses.setDescription('This attribute defines the security information (physical addresses) relevant for the entry. Coded in internal format, cryptographic methods may be used for privacy purposes.')
genPortIntPortConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 9, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genPortIntPortConnection.setStatus('mandatory')
if mibBuilder.loadTexts: genPortIntPortConnection.setDescription('The value of this attribute defines the internal port to which the port is connected. A value 0 of this attribute would indicate no internal port connection (stand-alone mode). Any other positive value equals the number of the internal port.')
genPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 9, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genPortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: genPortAdminStatus.setDescription('A disabled port neither transmits nor receives. The port must be explici- tenly enabled to restore operation. For token ring ports, this attribute is read-only.')
genPortSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 9, 1, 1, 11), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genPortSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: genPortSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
genIntPortTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 10, 1), )
if mibBuilder.loadTexts: genIntPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortTable.setDescription('Table of configuration attributes of FIBRONICS internal ports. Internal ports are physical and/or logical entities which transfer information and connect FIBRONICS modules to the internal networks (buses).')
genIntPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 10, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "genIntPortGroupId"), (0, "FIBRONICS-MIB", "genIntPortId"))
if mibBuilder.loadTexts: genIntPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortEntry.setDescription('An entry in the table, containing data about a single port.')
genIntPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genIntPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortGroupId.setDescription('Index which identifies the group inside the chassis for which this entry contains information. Equals the number of the slot by which the group containing the internal port is accessed. This value is never greater than chNumberOfSlots.')
genIntPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genIntPortId.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortId.setDescription('Index which identifies the port inside the group for which this entry contains information. This value is never greater than genGroupNumberOfIntPorts of the group to which the port belongs.')
genIntPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genIntPortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortAdminStatus.setDescription('Defines the capability of the internal port to transmit or receive data. A disabled internal port neither transmits or receives. The port must be explicitly enabled to restore operation.')
genIntPortActivityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("notActive", 1), ("dormant", 2), ("active", 3), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genIntPortActivityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortActivityStatus.setDescription('This attribute defines the status of internal ports that may be part of a redundancy scheme. NotActive - indicates a disabled port which cannot transmit or receive packets even if included in a redundancy scheme. Dormant - indicates an enabled port which does not transmit or receive packets, but because it is included in a redundancy scheme, it may at any moment become responsible for packet transmission and reception. Active - indicates that the port transmits and receives packets, serving as the main path in the redundant configuration.')
genIntPortBusConnNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genIntPortBusConnNumber.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortBusConnNumber.setDescription("The value of this attribute defines the bus to which the internal port is connected. The value '0' indicates that the port is disconnected from the bus.")
genIntPortBusConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("ethernet", 1), ("token-ring", 2), ("local-talk", 3), ("fddi", 4), ("high-speed", 5), ("other", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genIntPortBusConnType.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortBusConnType.setDescription('The value of this attribute defines the type of the bus to which the internal port is connected.')
genIntPortSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 10, 1, 1, 7), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genIntPortSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
genIntPortMonitorMode = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 10, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: genIntPortMonitorMode.setStatus('mandatory')
if mibBuilder.loadTexts: genIntPortMonitorMode.setDescription('This attribute enables to monitor a specified bus (RMON).')
softRedundancyTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 11, 1), )
if mibBuilder.loadTexts: softRedundancyTable.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyTable.setDescription('Table of attributes which define software redundancy links defined by means of the FIBRONICS chassis SNMP agents.')
softRedundancyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 11, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "softRedundancyId"))
if mibBuilder.loadTexts: softRedundancyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyEntry.setDescription('An entry in the table, containing data about a single software redundancy link.')
softRedundancyId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: softRedundancyId.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyId.setDescription('Index which identifies the software redundancy link which for which the current entry provides information.')
softRedundancyName = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 11, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: softRedundancyName.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyName.setDescription('Logical name of the software redundancy link')
softRedundancyGroupId1 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: softRedundancyGroupId1.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyGroupId1.setDescription('ID of the group to which the main port on the software redundancy link belongs. This value is never greater than chNumberOfSlots.')
softRedundancyPortId1 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 11, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: softRedundancyPortId1.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyPortId1.setDescription('ID of the main port on the software redundancy link.')
softRedundancyGroupId2 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 11, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: softRedundancyGroupId2.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyGroupId2.setDescription('ID of the group to which the secondary port on the software redundancy link belongs. This value is never greater than chNumberOfSlots.')
softRedundancyPortId2 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 11, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: softRedundancyPortId2.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyPortId2.setDescription('ID of the secondary port on the software redundancy link.')
softRedundancyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 11, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: softRedundancyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: softRedundancyStatus.setDescription("Status of the entry in the softRedundancy Table: valid(1) indicates that row is busy with meaningful values; createRequest(2) will be set by manager when creating a new row; underCreation(3) indicates that agent accepts create command and performs it; invalid(4) indicates that no meaningful values are present in the row. Managers set this value in order to transmit a 'Delete row' command to agent.")
ethAg = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 1))
ethAgTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 1, 1), )
if mibBuilder.loadTexts: ethAgTable.setStatus('mandatory')
if mibBuilder.loadTexts: ethAgTable.setDescription('Table of attributes which define configuration characteristics for FIBRONICS chassis SNMP agents which use Ethernet as in-band management protocol.')
ethAgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 1, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "ethAgId"))
if mibBuilder.loadTexts: ethAgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ethAgEntry.setDescription('An entry in the table, containing data about a single Ethernet agent.')
ethAgId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethAgId.setStatus('mandatory')
if mibBuilder.loadTexts: ethAgId.setDescription('Index which identifies the Ethernet agent for which the current entry provides information.')
ethAgPerfBusSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 1, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethAgPerfBusSelection.setStatus('mandatory')
if mibBuilder.loadTexts: ethAgPerfBusSelection.setDescription('Attribute describing the bus attached to the performance data collection hardware on those FIBRONICS agent hardware implementations which support configuration management on multi-Ethernet bus enclosures, but performan- ce data collection on a single bus.')
ethGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2))
ethGroupTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2, 1), )
if mibBuilder.loadTexts: ethGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupTable.setDescription('Table of attributes which define configuration characteristics for FIBRONICS Ethernet modules.')
ethGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "ethGroupId"))
if mibBuilder.loadTexts: ethGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupEntry.setDescription('An entry in the table, containing data about a single Ethernet module (group).')
ethGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupId.setDescription('Index which identifies the group inside the chassis for which this entry contains information. Equals the number of the slot by which the group is accessed. This value is never greater than chNumberOfSlots.')
ethGroupFIFO = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupFIFO.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupFIFO.setDescription('Value ON of this attribute describes an internal FIFO error sensed by the internal hardware mechanism of a FIBRONICS repeater.')
ethGroup10BTPlus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroup10BTPlus.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroup10BTPlus.setDescription('Value ON of this attribute defines activation of the 10BaseTPlus mode - a FIBRONICS extension of the 10BaseT standard.')
ethGroupIntPortsRedundancy = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroupIntPortsRedundancy.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupIntPortsRedundancy.setDescription('Value ON of this attribute defines a redundancy (backup) relationship between internal ports 1 and 2 on a FIBRONICS module.')
ethGroupBackboneMode = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroupBackboneMode.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupBackboneMode.setDescription('Value On of this attribute defines Backbone Mode of a sensor. Internal ports are enabled and the information path goes straightly from external port to internal bus, via corresponding internal port.')
ethGroupFOIRLPlusMode = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroupFOIRLPlusMode.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupFOIRLPlusMode.setDescription('Value On of this attribute defines FOIRL of a sensor. When this attribute has value ON, FOIRL Plus mode is enabled, while value OFF indicates stan- dard FOIRL mode.')
ethGroupWrongPortSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupWrongPortSelection.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupWrongPortSelection.setDescription('A value ON of this attribute warns of incorrect selection of enabled ports on sensors which impose restrictions on this configura- tion (e.g. integrated local bridges.)')
ethGroupBackupBus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroupBackupBus.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupBackupBus.setDescription('Defines the common secondary bus for Ethernet groups with bus redundancy defined at port level.')
ethGroupSingleBusMode = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupSingleBusMode.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupSingleBusMode.setDescription("Value 'on of this attribute defines bus-star mode for cards supporting this type of configuration.")
ethGroupSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2, 1, 1, 10), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
ethGroup10FBPlus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroup10FBPlus.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroup10FBPlus.setDescription('This variable enables/disables 10BaseFB plus mode.')
ethGroupMasterClock = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupMasterClock.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupMasterClock.setDescription('This attribute pertains to the SH-E16 chassis and defines the hub in the stack that generates the clock.')
ethGroupIdleTrx = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethGroupIdleTrx.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupIdleTrx.setDescription("This attribute is relevant to the LE-120Q/SQ modules and when set to 'off' after port disable terminates also light propagation (for redundancy tests).")
ethGroupMJLPStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGroupMJLPStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ethGroupMJLPStatus.setDescription('This attribute defines the MJLP error status on the group level.')
ethPort = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3))
ethPortTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1), )
if mibBuilder.loadTexts: ethPortTable.setStatus('mandatory')
ethPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "ethPortGroupId"), (0, "FIBRONICS-MIB", "ethPortId"))
if mibBuilder.loadTexts: ethPortEntry.setStatus('mandatory')
ethPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortGroupId.setDescription('Id of the group to which the port belongs.')
ethPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortId.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortId.setDescription('Unique Id of the port in the ethPortTable.')
ethPortFunctionalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 255))).clone(namedValues=NamedValues(("ok", 1), ("rld", 2), ("localJabber", 3), ("tld", 4), ("remoteJabber", 5), ("illSeq", 6), ("shortCirc", 7), ("partitionOrLocalJabber", 8), ("remoteFaultOrLockLost", 9), ("remoteFault", 10), ("lockLost", 11), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortFunctionalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortFunctionalStatus.setDescription('The value of this attribute reflects the functional status of FIBRONICS synchronous ports. Note that it is not mandatory that all ports support all the enumerated states. Here is the minimal set possible states: OK - fully functional port, transmitting and receiving packets. RLD - receive link down condition on the port. TLD - transmit link down condition on the port. LocalJabber - fault condition indicating that the port emitted jabber. RemoteJabber - fault condition indicating that remote jabber was sensed at the port. IllSeq - Fault condition indicating an illegal synchronization sequence at the port. ShortCircuit - short-circuit fault condition detected at the port. PartitionOrLocalJabber - RemoteFaultOrLockLoss - ')
ethPortManPart = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPortManPart.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortManPart.setDescription('Setting the value of this attribute to ON activates the manual partition mechanism at the port level. Setting the value of this attribute to OFF cancels the partition mechanism. The segment may reconnect after the reception of 32 packets. Attribute vaild for repeater modules from the LE-10 family.')
ethPortJabber = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortJabber.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortJabber.setDescription('Value ON of this attribute reflects jabber transmitted to the port by the hardware of a FIBRONICS repeater or transceiver, as a result of collisions detected on the port. Valid for all modules in the LE-10 and LE-15 families.')
ethPortNoAUILoop = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortNoAUILoop.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortNoAUILoop.setDescription('Value ON of this attribute indicates that a No AUI Loop fault condition was detected on an AUI repeater port. Valid for LE-10C family of modu- les.')
ethPortMJLP = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortMJLP.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortMJLP.setDescription('Value ON of this attribute describes an internal MJLP (MAU Jabber Lockup Protection) error sensed by the internal hardware mechanism of a FIBRONICS repeater. Valid for LE140XTF.')
ethPortFIFO = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortFIFO.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortFIFO.setDescription('Value ON of this attribute describes an internal FIFO error sensed by the internal hardware mechanism of a FIBRONICS repeater. Valid for LE140XTF.')
ethPortAutoPartitionState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("autoPartition", 1), ("notAutoPartition", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortAutoPartitionState.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortAutoPartitionState.setDescription('The AutoPart condition indicates that the port is currently partitioned by the auto-partition protection mechanism.')
ethPortSQETest = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPortSQETest.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortSQETest.setDescription('Settable attribute which allows activation of SQE test for FIBRONICS integrated transceivers.')
ethPortLastSourceAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortLastSourceAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortLastSourceAddr.setDescription('Ethernet source address of the last readable frame received by this port.')
ethPortUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("singleUser", 1), ("multiUser", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortUserStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortUserStatus.setDescription('Attribute defining the connection of a port to a single Ethernet source or to a multi-source (segment or star).')
ethPortMainBusSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPortMainBusSelection.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortMainBusSelection.setDescription('On cards with port-level redundancy, defines the main bus for each port instance as selected by user.')
ethPortTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortTraffic.setDescription('Counter for the number of bits received on this port in frames with legal length information.')
ethPortFramesReceivedOK = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortFramesReceivedOK.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortFramesReceivedOK.setDescription('A representation of the total number of frames of legal length that have not been corrupted in transmission. These frames can be encoded and decoded by the commonly available MACs and provide a measure of the network bandwidth being used. The number does not include frames received with frame-too-long, FCS, alignment errors, frames lost due to internal MAC sublayer errors, runts or pygmys.')
ethPortRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortRunts.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortRunts.setDescription('Counter for the number of collision fragments longer than a pygmy and shorter than a legal packet, detected on this port.')
ethPortPacketErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortPacketErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortPacketErrors.setDescription('Counter for the number of frames with errors detected on the port by the FIBRONICS agent hardware. This generic port error comprises too long packets, CRC and alignment errors.')
ethPortSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 18), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
ethPortCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortCollisions.setDescription('The number of collisions observed on a specified port. Relevant for MPR modules.')
ethPortPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortPartitions.setDescription('The number of partitions observed on a specified port. Relevant for MPR modules.')
ethPortPygmys = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 3, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethPortPygmys.setStatus('mandatory')
if mibBuilder.loadTexts: ethPortPygmys.setDescription('The number of pygmys observed on a specified port. Relevant for MPR modules.')
ethIntPort = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 4))
ethIntPortTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 4, 1), )
if mibBuilder.loadTexts: ethIntPortTable.setStatus('mandatory')
ethIntPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 4, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "ethIntPortGroupId"), (0, "FIBRONICS-MIB", "ethIntPortId"))
if mibBuilder.loadTexts: ethIntPortEntry.setStatus('mandatory')
ethIntPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntPortGroupId.setDescription('ID of the group to which the internal port belongs.')
ethIntPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntPortId.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntPortId.setDescription('ID of the internal port in the ethIntPortTable.')
ethIntPortPartition = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntPortPartition.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntPortPartition.setDescription('This condition indicates that the internal port is currently partitioned from the bus by the auto-partition protection mechanism.')
ethIntPortJabber = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntPortJabber.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntPortJabber.setDescription('Value ON of this attribute reflects jabber being transmitted to the bus by the hardware of a FIBRONICS repeater, as a result of collisions detected on the internal bus of the enclosure. This situation is similar to MJLP as defined by the Repeater Management standard.')
ethIntPortBackedUp = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethIntPortBackedUp.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntPortBackedUp.setDescription('Indicates that internal port is part of a redundancy scheme.')
ethBus = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5))
ethBusPerfTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 1), )
if mibBuilder.loadTexts: ethBusPerfTable.setStatus('mandatory')
ethBusPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "ethBusPerfAgId"), (0, "FIBRONICS-MIB", "ethBusPerfId"))
if mibBuilder.loadTexts: ethBusPerfEntry.setStatus('mandatory')
ethBusPerfAgId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusPerfAgId.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusPerfAgId.setDescription('ID of the agent in the ethBusPerfTable.')
ethBusPerfId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusPerfId.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusPerfId.setDescription('ID of the bus in the ethBusPerfTable.')
ethBusTrafficBuffer = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusTrafficBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTrafficBuffer.setDescription('Record of traffic for the last second with a resolution of 100 msec. The traffic is expressed in percents of the maximum Ethernet traffic and each record contains 10 readings, in the range 1..20, expressed on a log(10) scale ( value = 10*log10(percent) ).')
ethBusTrafficThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethBusTrafficThresh.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTrafficThresh.setDescription('Traffic threshold value. When exceeded, a trap is send to the management console. Expressed in percents of the maximum Ethernet traffic, in the range 1..20, expressed on a log(10) scale.')
ethBusPeakTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusPeakTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusPeakTraffic.setDescription('Maximal traffic value since last reset of hub or relay. Expressed in per- cents of the maximum Ethernet traffic, in the range 1..20, expressed on log(10) scale.')
ethBusTotalCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusTotalCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTotalCollisions.setDescription('Counter incremented every time the hub enters a condition caused by simultaneous transmission and detection of external activity on one or more of its ports.')
ethBusTotalPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusTotalPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTotalPackets.setDescription('Counter for number of packets (good and errors) detected on the Ethernet bus.')
ethBusTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTotalErrors.setDescription('Counter for number of errors detected on the Ethernet bus. Does not take into account the collisions.')
ethBusTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusTraffic.setDescription('Last traffic reading (sampling time = 100 msec). The traffic is expressed in percents of the maximum Ethernet traffic in the range 1..20, expressed on a log(10) scale ( value = 10*log10(percent) ).')
ethBusUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusUtilization.setDescription('Last traffic reading (sampling time = 100 msec). The traffic is expressed in percents of the maximum Ethernet traffic.')
ethBusPeakUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusPeakUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusPeakUtilization.setDescription('Maximal traffic value since last reset of agent. Expressed in percents of the maximum effective Ethernet traffic.')
ethBusClockTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 2), )
if mibBuilder.loadTexts: ethBusClockTable.setStatus('mandatory')
ethBusClockEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 2, 1), ).setIndexNames((0, "FIBRONICS-MIB", "ethBusClockBusId"), (0, "FIBRONICS-MIB", "ethBusClockId"))
if mibBuilder.loadTexts: ethBusClockEntry.setStatus('mandatory')
ethBusClockBusId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusClockBusId.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusClockBusId.setDescription('ID of the bus in the ethBusClockTable.')
ethBusClockId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusClockId.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusClockId.setDescription('ID of the clock in the ethBusClockTable.')
ethBusClockTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 12, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("ok", 1), ("clockFailure", 2), ("busFailure", 3), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethBusClockTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: ethBusClockTestResult.setDescription('Values clockFailure and busFailure define the faulty statuses for clock tests. The test is performed by LCL100 module.')
tokRing = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1))
tokRingTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1), )
if mibBuilder.loadTexts: tokRingTable.setStatus('mandatory')
tokRingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "tokRingAgId"), (0, "FIBRONICS-MIB", "tokRingId"))
if mibBuilder.loadTexts: tokRingEntry.setStatus('mandatory')
tokRingAgId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingAgId.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingAgId.setDescription('ID of the agent to which the ring belongs in the tokRingTable.')
tokRingId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingId.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingId.setDescription('ID of the ring in the tokRingTable.')
tokRingLeftSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingLeftSlot.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingLeftSlot.setDescription('Slot number of the left-most slot of the ring.')
tokRingRightSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokRingRightSlot.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingRightSlot.setDescription('Slot number of the right-most slot of the ring that has a lobe port. ')
tokRingTrafficBuffer = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingTrafficBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingTrafficBuffer.setDescription('Record of traffic for the last second with a resolution of 100 msec. The traffic is expressed in percents of the maximum effective TR traffic (token messages are excluded) and each record contains 10 readings, in range 1..20 on log(10) scale.')
tokRingTrafficThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokRingTrafficThresh.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingTrafficThresh.setDescription('Traffic threshold value. When exceeded, a trap is send to the management console. Expressed in percents of the maximum effective TR traffic (token messages are excluded) in the range 1..20 on log(10) scale.')
tokRingPeakTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingPeakTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingPeakTraffic.setDescription('Maximal traffic value since last reset of agent. Expressed in percents of the maximum effective TR traffic (token messages are excluded), in the range 1..20 on log(10) scale.')
tokRingNumberOfStations = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingNumberOfStations.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingNumberOfStations.setDescription('Number of Token Ring stations (controllers) detected on the ring. The TR controller of the agent card is included in this count.')
tokRingConfiguration = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingConfiguration.setDescription('Configuration attribute describing the list of physical addresses detected on the Token Ring. Coded in internal FIBRONICS application format. ')
tokRingBeaconing = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingBeaconing.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingBeaconing.setDescription('This attribute indicates if a beaconing condition is currently detected on the ring.')
tokRingBeaconingStation = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingBeaconingStation.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingBeaconingStation.setDescription('The MAC address of the last station which was detected as sending Beaconing MAC frames on the ring.')
tokRingStationsMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingStationsMatch.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingStationsMatch.setDescription('This attribute indicates matching between the number of stations detected on the ring between the current agent and the next agent on Up Stream sense and the number of connected lobe ports.Used by the port address correlation mechanism.')
tokRingTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingTraffic.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingTraffic.setDescription('Last traffic reading (sampling time = 100 msec). The traffic is expressed in percents of the maximum Ethernet traffic in the range 1..20, expressed on a log(10) scale ( value = 10*log10(percent) ).')
tokRingSecurityMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("perPort", 1), ("perRing", 2), ("disabled", 3), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokRingSecurityMethod.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingSecurityMethod.setDescription('Security scheme selected by the user.')
tokRingSecurityPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokRingSecurityPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingSecurityPolicy.setDescription('Security policy (trap only or trap and disconnect) selected for the ring. Coded in FIBRONICS internal format.')
tokRingSecureAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 16), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokRingSecureAddr.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingSecureAddr.setDescription('Secure addresses assigned to the ring. Coded in FIBRONICS internal format.')
tokRingLastViolation = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingLastViolation.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingLastViolation.setDescription('MAC address of a last detected intruder.')
tokRingUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingUtilization.setDescription('Last traffic reading (sampling time = 100 msec). The traffic is expressed in percents of the maximum Token Ring traffic.')
tokRingPeakUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 1, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokRingPeakUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: tokRingPeakUtilization.setDescription('Maximal traffic value since last reset of agent. Expressed in percents of the maximum effective TR traffic (token messages are excluded).')
tokGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2))
tokGroupTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 1), )
if mibBuilder.loadTexts: tokGroupTable.setStatus('mandatory')
tokGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "tokGroupId"))
if mibBuilder.loadTexts: tokGroupEntry.setStatus('mandatory')
tokGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupId.setDescription('Number of the slot in which the group is installed.')
tokGroupAutoRightLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupAutoRightLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupAutoRightLoop.setDescription('Value ON of this attribute signifies that a hardware loop was automatically created on a Token Ring module which does not sense the existence of another token ring group on the right hand side.')
tokGroupAutoLeftLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupAutoLeftLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupAutoLeftLoop.setDescription('Value ON of this attribute signifies that a hardware loop was automatically created on a Token Ring module which does not sense the existence of another token ring group on the left hand side.')
tokGroupManRightLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupManRightLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupManRightLoop.setDescription('Setting this attribute to ON signifies a command to the hardware to create a loop on the Token Ring module which isolates the ring from the right hand side.')
tokGroupManLeftLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupManLeftLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupManLeftLoop.setDescription('Setting this attribute to ON signifies a command to the hardware to create a loop on the Token Ring module which isolates the ring from the left hand side.')
tokGroupRightNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("exist", 1), ("notExist", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupRightNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupRightNeighbor.setDescription('Attribute defining the existence of a neighbor another token ring group on the right hand side of the module.')
tokGroupLeftNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("exist", 1), ("notExist", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupLeftNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupLeftNeighbor.setDescription('Attribute defining the existence of a neighbor another token ring group on the left hand side of the module.')
tokGroupIOMode = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 255))).clone(namedValues=NamedValues(("single", 1), ("dualRingIn", 2), ("dualRingOut", 3), ("illegalMode", 4), ("lobe", 5), ("intRepeater", 6), ("star", 7), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupIOMode.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupIOMode.setDescription('Attribute defining the I/O mode (single, dual-ring-in, dual-ring-out) Lobe, Internal Repeater or Star) of a module from the the LTR-IO family.')
tokGroupBridgeMode = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("modeA", 1), ("modeB", 2), ("modeC", 3), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupBridgeMode.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupBridgeMode.setDescription('Attribute describing the operational mode of the bridge. For ITLB the following modes are defined: - Mode A: First channel connected to an external ring (RI,RO connectors) and second channel connected to an internal ring; - Mode B: First channel connected to an external ring by a DTE connector and second channel connected to an internal ring; - Mode C: First channel connected to an internal left ring and second channel connected to an internal right ring.')
tokGroupManLinkLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupManLinkLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupManLinkLoop.setDescription('Setting the value of this attribute to ON instructs the hardware of a FIBRONICS Token Ring repeater module to close the loop in the direction of the external connection.')
tokGroupManBusLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupManBusLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupManBusLoop.setDescription('Setting the value of this attribute to ON instructs the hardware of a FIBRONICS Token Ring repeater module to close the loop in the direction of the internal bus.')
tokGroupAutoLinkLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupAutoLinkLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupAutoLinkLoop.setDescription('Value ON of this attribute signifies that a hardware loop has been auto- matically closed by the hardwar of the FIBRONICS Token Ring repeater as a result of problems on the external link.')
tokGroupAutoBusLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupAutoBusLoop.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupAutoBusLoop.setDescription('Value ON of this attribute signifies that a hardware loop has been auto- matically closed by the hardware of the FIBRONICS Token Ring repeater as a result of problems on the internal bus.')
tokGroupSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 1, 1, 14), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
tokGroupRingTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 2), )
if mibBuilder.loadTexts: tokGroupRingTable.setStatus('mandatory')
tokGroupRingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 2, 1), ).setIndexNames((0, "FIBRONICS-MIB", "tokGroupRingGroupId"), (0, "FIBRONICS-MIB", "tokGroupRingId"))
if mibBuilder.loadTexts: tokGroupRingEntry.setStatus('mandatory')
tokGroupRingGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupRingGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupRingGroupId.setDescription('ID of the group to which the ring belongs.')
tokGroupRingId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupRingId.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupRingId.setDescription('ID of the ring.')
tokGroupRingSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("oneMegabit", 2), ("fourMegabit", 3), ("sixteenMegabit", 4), ("sixteenMgbEarly", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokGroupRingSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupRingSpeed.setDescription('Attribute describing the bandwidth of the ring.')
tokGroupRingInserted = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInserted", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokGroupRingInserted.setStatus('mandatory')
if mibBuilder.loadTexts: tokGroupRingInserted.setDescription('Indicates that the bridge interface has inserted itself into the ring.')
tokPort = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 3))
tokPortTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 3, 1), )
if mibBuilder.loadTexts: tokPortTable.setStatus('mandatory')
tokPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 3, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "tokPortGroupId"), (0, "FIBRONICS-MIB", "tokPortId"))
if mibBuilder.loadTexts: tokPortEntry.setStatus('mandatory')
tokPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortGroupId.setDescription('ID of the group to which the token ring port belongs.')
tokPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortId.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortId.setDescription('ID of the port in the tokPortTable.')
tokPortBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokPortBypass.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortBypass.setDescription('Setting the value of this attribute to ON causes the by- passing of the TokenRing FIBRONICS port.')
tokPortConnected = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("connected", 1), ("notConnected", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortConnected.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortConnected.setDescription('Attribute which describes the connection status of a Token Ring port (inclusion of the Token Ring controller in the ring).')
tokPortTCP = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokPortTCP.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortTCP.setDescription('Setting the value of this attribute to ON causes the activation of the cable-fault detection mechanism.')
tokPortCableFault = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortCableFault.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortCableFault.setDescription('Value ON of this attribute signifies the detection of a cable-fault on this specific Token Ring port.')
tokPortFunctionalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 255))).clone(namedValues=NamedValues(("ok", 1), ("rld", 2), ("tld", 4), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortFunctionalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortFunctionalStatus.setDescription('The value of this attribute reflects the functional status of FIBRONICS Token Ring ports. Note that it is not mandatory that a certain port support all the enumerated states. Here is the lest of the possible states: OK - fully functional port, transmitting and receiving packets. RLD - receive link down condition on the port. TLD - transmit link down condition on the port.')
tokPortLastSourceAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 3, 1, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortLastSourceAddr.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortLastSourceAddr.setDescription('MAC source address of the last readable frame received by this port.')
tokPortSpecificOID = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 3, 1, 1, 9), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortSpecificOID.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortSpecificOID.setDescription('This attribute provides the OID of another group containing additional more specific information regarding this instance.')
tokPortRingSpeedError = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 13, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tokPortRingSpeedError.setStatus('mandatory')
if mibBuilder.loadTexts: tokPortRingSpeedError.setDescription(" This attribute is set to 'on' when the station tries to enter the ring with the speed different from the ring's one.")
tsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 14, 1))
tsGroupTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 14, 1, 1), )
if mibBuilder.loadTexts: tsGroupTable.setStatus('mandatory')
tsGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 14, 1, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "tsGroupId"))
if mibBuilder.loadTexts: tsGroupEntry.setStatus('mandatory')
tsGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 14, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: tsGroupId.setDescription('Number of the slot in which the group is installed.')
tsGroupLATStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 14, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsGroupLATStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tsGroupLATStatus.setDescription('Value ON of this attribute means that LAT protocol is Enabled on the FIBRONICS Ethernet module.')
tsGroupOperationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 14, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("diagnostics", 1), ("diagnosticsFailure", 2), ("loading", 3), ("loadingFailure", 4), ("operational", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsGroupOperationMode.setStatus('mandatory')
if mibBuilder.loadTexts: tsGroupOperationMode.setDescription('This attribute describes the operation mode of the module in a multiprocessor configuration sensor, as reported by interprocessors communication.')
ltalkPort = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 15, 1))
ltalkPortTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 15, 1, 1), )
if mibBuilder.loadTexts: ltalkPortTable.setStatus('mandatory')
ltalkPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 15, 1, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "ltalkPortGroupId"), (0, "FIBRONICS-MIB", "ltalkPortId"))
if mibBuilder.loadTexts: ltalkPortEntry.setStatus('mandatory')
ltalkPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 15, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ltalkPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: ltalkPortGroupId.setDescription('Number of the group to which the port belongs.')
ltalkPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 15, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ltalkPortId.setStatus('mandatory')
if mibBuilder.loadTexts: ltalkPortId.setDescription('ID of the port in the ltalkPortTable.')
ltalkPortTest = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 15, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ltalkPortTest.setStatus('mandatory')
if mibBuilder.loadTexts: ltalkPortTest.setDescription('A value ON of this attribute indicates that a port test should be performed upon the port defined by the attribute instance.')
ltalkPortTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 15, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("faulty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ltalkPortTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: ltalkPortTestResult.setDescription('Indicates the result of a port test performed on this port.')
ltalkPortJam = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 15, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ltalkPortJam.setStatus('mandatory')
if mibBuilder.loadTexts: ltalkPortJam.setDescription('An ON value of this attribute indicates a Jam error on the specific port.')
clGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 16, 1))
clGroupTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 16, 1, 1), )
if mibBuilder.loadTexts: clGroupTable.setStatus('mandatory')
clGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 16, 1, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "clGroupId"))
if mibBuilder.loadTexts: clGroupEntry.setStatus('mandatory')
clGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 16, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: clGroupId.setDescription('Number of the slot in which the group is installed.')
clGroupClockRedundancy = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 16, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clGroupClockRedundancy.setStatus('mandatory')
if mibBuilder.loadTexts: clGroupClockRedundancy.setDescription('Value ON of this attribute defines a redundancy (backup) relationship between the internal and external clocks on the LCL100 module.')
clGroupMainClock = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 16, 1, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clGroupMainClock.setStatus('mandatory')
if mibBuilder.loadTexts: clGroupMainClock.setDescription("Value of this attribute is an index into clPortTable, and defines the clock that should operate or a main clock in redundancy scheme. Serves as 'Clock selection' switch on the card.")
clGroupTestClocks = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 16, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clGroupTestClocks.setStatus('mandatory')
if mibBuilder.loadTexts: clGroupTestClocks.setDescription('A value ON of this attribute indicates that a test should be performed on all clock ports.')
clPort = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 16, 2))
clPortTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 16, 2, 1), )
if mibBuilder.loadTexts: clPortTable.setStatus('mandatory')
clPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 16, 2, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "clPortGroupId"), (0, "FIBRONICS-MIB", "clPortId"))
if mibBuilder.loadTexts: clPortEntry.setStatus('mandatory')
clPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 16, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: clPortGroupId.setDescription('Number of the group to which the port belongs.')
clPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 16, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clPortId.setStatus('mandatory')
if mibBuilder.loadTexts: clPortId.setDescription('ID of the port in the clPortTable.')
clPortFunctionalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 16, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("faulty", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clPortFunctionalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: clPortFunctionalStatus.setDescription('Indicates whether the clock is faulty or not.')
lBoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 17, 1))
lUnknownBoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 17, 1, 1))
lLET18BoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 17, 1, 2))
lLET3BoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 17, 1, 3))
lLET36BoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 17, 1, 4))
lLET18EBoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 17, 1, 5))
lLERT40BoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 17, 1, 6))
lLET10BoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 17, 1, 7))
lFDX100BoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 17, 1, 8))
lSTACKBoxOID = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 17, 1, 9))
iwb = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 1))
iwr = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 2))
itr = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3))
iwrGroupTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 2, 1), )
if mibBuilder.loadTexts: iwrGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: iwrGroupTable.setDescription('Attributes pertaining to the module.')
iwrGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 2, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "iwrGroupId"))
if mibBuilder.loadTexts: iwrGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: iwrGroupEntry.setDescription('An entry in the table.')
iwrGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: iwrGroupId.setDescription('Slot number in which the module is located.')
iwrOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("run", 1), ("boot", 2), ("fail", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrOperState.setStatus('mandatory')
if mibBuilder.loadTexts: iwrOperState.setDescription('One of the possible states of the module.')
iwrPMState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrPMState.setStatus('mandatory')
if mibBuilder.loadTexts: iwrPMState.setDescription('The state of the Processor Module.')
iwrIOMState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrIOMState.setStatus('mandatory')
if mibBuilder.loadTexts: iwrIOMState.setDescription('The state of the Input/Output Module.')
iwrWANTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 2, 2), )
if mibBuilder.loadTexts: iwrWANTable.setStatus('mandatory')
if mibBuilder.loadTexts: iwrWANTable.setDescription('WAN data table.')
iwrWANEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 2, 2, 1), ).setIndexNames((0, "FIBRONICS-MIB", "iwrWANGroupId"), (0, "FIBRONICS-MIB", "iwrWANPortId"))
if mibBuilder.loadTexts: iwrWANEntry.setStatus('mandatory')
if mibBuilder.loadTexts: iwrWANEntry.setDescription('Entry in the table.')
iwrWANGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrWANGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: iwrWANGroupId.setDescription('Slot number in which the module is located.')
iwrWANPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrWANPortId.setStatus('mandatory')
if mibBuilder.loadTexts: iwrWANPortId.setDescription('WAN port index.')
iwrWANConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("connected", 1), ("disconnected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrWANConnection.setStatus('mandatory')
if mibBuilder.loadTexts: iwrWANConnection.setDescription('WAN connection status.')
iwrWANPortCableType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("x21", 1), ("rs232", 2), ("v35", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iwrWANPortCableType.setStatus('mandatory')
if mibBuilder.loadTexts: iwrWANPortCableType.setDescription('Cable type connected to the specified WAN port.')
itrGroupTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 1), )
if mibBuilder.loadTexts: itrGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: itrGroupTable.setDescription('Table of attributes pertaining to the ITRE module.')
itrGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "itrGroupId"))
if mibBuilder.loadTexts: itrGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: itrGroupEntry.setDescription('An entry in the table.')
itrGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: itrGroupId.setDescription('Slot number in which the module is located.')
itrMainSWVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrMainSWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: itrMainSWVersion.setDescription('Software version of the main CPU.')
itrConfigState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("local", 1), ("remote", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrConfigState.setStatus('mandatory')
if mibBuilder.loadTexts: itrConfigState.setDescription('Configuration state of the module.')
itrModuleState = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("oper", 1), ("load", 2), ("setup", 3), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrModuleState.setStatus('mandatory')
if mibBuilder.loadTexts: itrModuleState.setDescription('State of the ISTC/IFTC modules.')
itrLinkTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 2), )
if mibBuilder.loadTexts: itrLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkTable.setDescription('ITRE links table.')
itrLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 2, 1), ).setIndexNames((0, "FIBRONICS-MIB", "itrLinkGroupId"), (0, "FIBRONICS-MIB", "itrLinkPortId"))
if mibBuilder.loadTexts: itrLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkEntry.setDescription('Entry in the table.')
itrLinkGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrLinkGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkGroupId.setDescription('Slot number in which the module is located.')
itrLinkPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrLinkPortId.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkPortId.setDescription('Link identifier.')
itrLinkIf = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("v11", 1), ("v24", 2), ("v35", 3), ("dte-dce", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrLinkIf.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkIf.setDescription('Interface type.')
itrLinkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sync", 1), ("async", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: itrLinkMode.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkMode.setDescription('Synchronous or asynchronous modes on the link.')
itrLinkAsyncRate = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 255))).clone(namedValues=NamedValues(("r2400", 1), ("r4800", 2), ("r9600", 3), ("r14400", 4), ("r19200", 5), ("r38400", 6), ("r56000", 7), ("r57600", 8), ("r64000", 9), ("r112000", 10), ("unknown", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: itrLinkAsyncRate.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkAsyncRate.setDescription('Possible link speeds that can be set in asynchronous mode.')
itrLinkSyncRate = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 255))).clone(namedValues=NamedValues(("r1200", 1), ("r2400", 2), ("r4800", 3), ("r9600", 4), ("r14400", 5), ("r19200", 6), ("r38400", 7), ("r48000", 8), ("r56000", 9), ("r57600", 10), ("r64000", 11), ("r112000", 12), ("r128000", 13), ("r256000", 14), ("r384000", 15), ("r512000", 16), ("r786000", 17), ("r1024000", 18), ("r1544000", 19), ("r2048000", 20), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrLinkSyncRate.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkSyncRate.setDescription('Link speeds in synchronous mode.')
itrLinkParity = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: itrLinkParity.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkParity.setDescription('This attribute enables/disables parity checking.')
itrLinkParityEvenOdd = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("even", 1), ("odd", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: itrLinkParityEvenOdd.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkParityEvenOdd.setDescription('Even or odd parity.')
itrLinkStopBit = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("none", 3), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: itrLinkStopBit.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkStopBit.setDescription("Number of stop bits (1 or 2 ) in asynchronous mode. The value 'none' is returned in synchronous mode.")
itrLinkRemoteLANConn = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("connected", 1), ("disconnected", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrLinkRemoteLANConn.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkRemoteLANConn.setDescription('This attribute shows whether the remote ITRE is connected to the LAN.')
itrLinkFunctionalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 21, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2), ("noRxClk", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: itrLinkFunctionalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: itrLinkFunctionalStatus.setDescription('The attribute represents the status of the WAN link.')
lse = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1))
lseGroupTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 1), )
if mibBuilder.loadTexts: lseGroupTable.setStatus('mandatory')
lseGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "lseGroupId"))
if mibBuilder.loadTexts: lseGroupEntry.setStatus('mandatory')
lseGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupId.setDescription('Slot number in which the group is installed.')
lseGroupFastOpen = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupFastOpen.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupFastOpen.setDescription('Setting the value of this attribute to ON activates the port for short idle time when code violation was detected.')
lseGroup10MSqlt = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroup10MSqlt.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroup10MSqlt.setDescription('Setting the value of this attribute to ON activates the mechanism of detection preamble of 10Mhz.')
lseGroupSmartSqlt = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupSmartSqlt.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupSmartSqlt.setDescription('Control the mechnism of the input sensitivity of the port.')
lseGroupCParameter = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupCParameter.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupCParameter.setDescription('Defines the number of consecutive collisions the port waits before it ceases transmitting of 512 bits time toward the station.')
lseGroupIPGJamLength = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 112))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupIPGJamLength.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupIPGJamLength.setDescription('Defines the IPG jam length in Ethernet bit time (100nS) start at 16 bit time in steps of 16 to 112 bit time. Any number between the defined values will take to nearest smaller value.')
lseGroupJamLength = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupJamLength.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupJamLength.setDescription('Defines the Jam Length in time start from 8 (800micro-seconds) to 120 (12mili-seconds). Each step of 8 is equal 800micro-seconds.')
lseGroupDataBlinderLength = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(48, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupDataBlinderLength.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupDataBlinderLength.setDescription('Defines the Data Blinder Length in Ethernet bit time (100nS) start at 48 bit time in steps of 8 to 120 bit time. Any number between the defined values will take to nearest smaller value')
lseGroupIPGDataLength = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(48, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupIPGDataLength.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupIPGDataLength.setDescription('Defines the IPG data length in Ethernet bit time (100nS) start at 48 bit time in steps of 8 to 120 bit time. Any number between the defined values will take to nearest smaller value.')
lseGroupActiveMonitor = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseGroupActiveMonitor.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupActiveMonitor.setDescription('This attribute defines the status of the module which is the high-speed bus active monitor.')
lseGroupBackBone = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupBackBone.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupBackBone.setDescription('The board is in the Backbone Mode. lse208 - upper subgroup is RX only (ports 1-4) and lower subgroup is TX to line only. lse808 - the first port is RX from line only, the second - TX to line only, the rest are in regular 10BaseT mode.')
lseGroupSetDefaults = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseGroupSetDefaults.setStatus('mandatory')
if mibBuilder.loadTexts: lseGroupSetDefaults.setDescription('Set all hardware parameters to their default values.')
lseIntPort = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2))
lseIntPortTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1), )
if mibBuilder.loadTexts: lseIntPortTable.setStatus('mandatory')
lseIntPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "lseIntPortGroupId"), (0, "FIBRONICS-MIB", "lseIntPortId"))
if mibBuilder.loadTexts: lseIntPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortEntry.setDescription('An entry in the table, containing data about a single internal LanSwitch bank.')
lseIntPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortGroupId.setDescription('Id of the group to which the port belongs.')
lseIntPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortId.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortId.setDescription('Number of LanSwitch port in the board.')
lseIntPortIOMode = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortIOMode.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortIOMode.setDescription('All packets on the high-speed bus that were not captured by any regular port are captured by the I/O port.')
lseIntPortResetSwitchCAM = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortResetSwitchCAM.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortResetSwitchCAM.setDescription('Acting like toggle switch thus always returns OFF')
lseIntPortVideoPacket = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortVideoPacket.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortVideoPacket.setDescription('Set all Tx packets toward the high-speed bus to video type packets.')
lseIntPortPriorityStateMachine = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortPriorityStateMachine.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortPriorityStateMachine.setDescription('Setting the value of this attribute to ON activates the priority mechanism.')
lseIntPortActiveBroadcastPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortActiveBroadcastPriority.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortActiveBroadcastPriority.setDescription('Setting the value of this attribute to ON activates the active broadcast mode in priority mechanism.')
lseIntPortPriorityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 255))).clone(namedValues=NamedValues(("broadcast", 1), ("multicast", 2), ("video", 3), ("regular", 4), ("default", 5), ("mngrTerminal", 6), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortPriorityLevel.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortPriorityLevel.setDescription('This attribute defines the priority levels of Tx packets toward the high-speed bus. The highest priority is broadcast.')
lseIntPortSuperPriorityEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortSuperPriorityEnable.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortSuperPriorityEnable.setDescription('The value ON defines the retry parameter for the priority level mechanism.')
lseIntPortRoutingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("generic", 1), ("net", 2), ("dstPort", 3), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortRoutingMode.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortRoutingMode.setDescription("Generic - examines all the packets that are not members of any virtual network. Net - examines only the packets that have the port's network number.")
lseIntPortGlobal = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortGlobal.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortGlobal.setDescription('Port in a network routing mode that examines all packets that are not members of all virtual networks.')
lseIntPortLearnIOCAM = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortLearnIOCAM.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortLearnIOCAM.setDescription('The ability of an I/O port to learn incoming MAC addresses received in its port and store them in its CAM. The CAM is limited to total of 8 MAC addresses.')
lseIntPortSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortSecurity.setDescription('Setting the value of this attribute to ON activates the security mode.')
lseIntPortIgnoreBusy = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortIgnoreBusy.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortIgnoreBusy.setDescription('Setting the value of this attribute to ON activates the ignore busy mode. The busy signal toward the high-speed bus is not activated even though the TX buffer is full.')
lseIntPortRetryPriorityLevel1 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortRetryPriorityLevel1.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortRetryPriorityLevel1.setDescription('The port increases the priority level of the high-speed bus packets after the defined number (1..32) trials.')
lseIntPortRetryPriorityLevel2 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortRetryPriorityLevel2.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortRetryPriorityLevel2.setDescription('The port increases the priority level of the high-speed bus packets after the defined number (1..32) trials.')
lseIntPortRetryPriorityLevel3 = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortRetryPriorityLevel3.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortRetryPriorityLevel3.setDescription('The port increases the priority level of the high-speed bus packets after the defined number (1..32) trials.')
lseIntPortIgnoreProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("ignore", 1), ("not-ignore", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortIgnoreProtocolType.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortIgnoreProtocolType.setDescription('Any packet regardless of thye protocol type is received from the high-speed bus.')
lseIntPortCompanyMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 19), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortCompanyMAC.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortCompanyMAC.setDescription('The attribute defines the first three bytes of the MAC address of the video host server.')
lseIntPortTxSafetyZone = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortTxSafetyZone.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortTxSafetyZone.setDescription('Defines the Tx Safety Zone in bits.')
lseIntPortRxSafetyZone = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortRxSafetyZone.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortRxSafetyZone.setDescription('Defines the Rx Safety Zone in bits.')
lseIntPortTxBurstLength = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortTxBurstLength.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortTxBurstLength.setDescription('Defines the TX Burst Length in bits.')
lseIntPortSecurityIntruder = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortSecurityIntruder.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortSecurityIntruder.setDescription('The value ON of this attribute reflects a security violation occurrence.')
lseIntPortJabber = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lseIntPortJabber.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortJabber.setDescription('Value ON of this attribute reflects the jabber transmitted to the port by the high-speed bus.')
lseIntPortCAM = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(56, 56)).setFixedLength(56)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortCAM.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortCAM.setDescription('Fifty six bytes of MAC addresses. Each byte with the port number is followed by six byte MAC address.')
lseIntPortVideoStateMachine = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortVideoStateMachine.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortVideoStateMachine.setDescription('Setting the value of this attribute to ON activates the video state machine mode. Received packets are filtered by demand from the station.')
lseIntPortTransmitWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 2, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lseIntPortTransmitWeight.setStatus('mandatory')
if mibBuilder.loadTexts: lseIntPortTransmitWeight.setDescription('Defines the Transmit Weight of the frames toward the high-speed bus.')
lsePort = MibIdentifier((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 3))
lsePortTable = MibTable((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 3, 1), )
if mibBuilder.loadTexts: lsePortTable.setStatus('mandatory')
lsePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 3, 1, 1), ).setIndexNames((0, "FIBRONICS-MIB", "lsePortGroupId"), (0, "FIBRONICS-MIB", "lsePortId"))
if mibBuilder.loadTexts: lsePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lsePortEntry.setDescription('An entry in the table containing data about a single external switch port.')
lsePortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsePortGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: lsePortGroupId.setDescription('Id of the group to which the port belongs.')
lsePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsePortId.setStatus('mandatory')
if mibBuilder.loadTexts: lsePortId.setDescription('Number of LanSwitch port in the board.')
lsePortPolarity = MibTableColumn((1, 3, 6, 1, 4, 1, 22, 101, 2, 2, 19, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsePortPolarity.setStatus('mandatory')
if mibBuilder.loadTexts: lsePortPolarity.setDescription('Setting the value of this attribute to ON activates the automatic port polarity detection mode.')
mibBuilder.exportSymbols("FIBRONICS-MIB", lseIntPortEntry=lseIntPortEntry, lseIntPortCAM=lseIntPortCAM, genPortAdminStatus=genPortAdminStatus, lseGroupCParameter=lseGroupCParameter, lseGroupJamLength=lseGroupJamLength, ethBusTotalErrors=ethBusTotalErrors, iwrWANGroupId=iwrWANGroupId, chassis=chassis, clPortId=clPortId, tokPortFunctionalStatus=tokPortFunctionalStatus, clPortFunctionalStatus=clPortFunctionalStatus, chMgrPollInterval=chMgrPollInterval, tokPort=tokPort, softRedundancyEntry=softRedundancyEntry, ltalkPort=ltalkPort, ethGroupBackupBus=ethGroupBackupBus, clGroup=clGroup, chNumberOfLocalTalkBuses=chNumberOfLocalTalkBuses, chReset=chReset, clPortGroupId=clPortGroupId, itrLinkRemoteLANConn=itrLinkRemoteLANConn, genGroupAutoMan=genGroupAutoMan, chFbrAgMgmtBusSelection=chFbrAgMgmtBusSelection, genGroupFullConfig=genGroupFullConfig, tokGroupRingTable=tokGroupRingTable, ethGroupIntPortsRedundancy=ethGroupIntPortsRedundancy, chFbrAgFaultTraps=chFbrAgFaultTraps, lseIntPortResetSwitchCAM=lseIntPortResetSwitchCAM, lsePortId=lsePortId, ethPortEntry=ethPortEntry, ethPortMainBusSelection=ethPortMainBusSelection, lseIntPortIOMode=lseIntPortIOMode, ethPortGroupId=ethPortGroupId, lseIntPortTxBurstLength=lseIntPortTxBurstLength, lseIntPortPriorityStateMachine=lseIntPortPriorityStateMachine, ethBusClockTable=ethBusClockTable, iwrPMState=iwrPMState, tokPortTCP=tokPortTCP, itrLinkGroupId=itrLinkGroupId, ethPortFunctionalStatus=ethPortFunctionalStatus, lseGroupTable=lseGroupTable, iwrWANEntry=iwrWANEntry, genGroupSpecificOID=genGroupSpecificOID, tokRingPeakTraffic=tokRingPeakTraffic, chFbrAgDateTime=chFbrAgDateTime, chFbrAgSecAddrConfig=chFbrAgSecAddrConfig, itrGroupTable=itrGroupTable, ethGroupTable=ethGroupTable, chNumberOfTRBuses=chNumberOfTRBuses, ethBusPerfId=ethBusPerfId, chHWPSUEntry=chHWPSUEntry, ltalkPortEntry=ltalkPortEntry, clGroupMainClock=clGroupMainClock, chMgr=chMgr, ts=ts, clGroupTable=clGroupTable, ethPortJabber=ethPortJabber, ethPortRunts=ethPortRunts, tokPortGroupId=tokPortGroupId, ethPortSQETest=ethPortSQETest, ethPortLastSourceAddr=ethPortLastSourceAddr, itrLinkEntry=itrLinkEntry, itrGroupId=itrGroupId, itrLinkStopBit=itrLinkStopBit, lseIntPortSecurityIntruder=lseIntPortSecurityIntruder, lseIntPortSecurity=lseIntPortSecurity, ltalkPortTest=ltalkPortTest, lLET10BoxOID=lLET10BoxOID, fibronics=fibronics, lseGroupSmartSqlt=lseGroupSmartSqlt, ltalk=ltalk, genPortId=genPortId, lsePortEntry=lsePortEntry, chFbrAgSoftFaultTraps=chFbrAgSoftFaultTraps, genIntPortGroupId=genIntPortGroupId, ethBusClockId=ethBusClockId, ethPortSpecificOID=ethPortSpecificOID, chFbrAgGroupEnrollDeenrollTraps=chFbrAgGroupEnrollDeenrollTraps, chFbrAgSpecificOID=chFbrAgSpecificOID, lLERT40BoxOID=lLERT40BoxOID, chNumberOfSlots=chNumberOfSlots, lseIntPortTxSafetyZone=lseIntPortTxSafetyZone, lsePortPolarity=lsePortPolarity, lseGroupDataBlinderLength=lseGroupDataBlinderLength, tsGroupId=tsGroupId, softRedundancyPortId1=softRedundancyPortId1, ethBusTrafficThresh=ethBusTrafficThresh, chFbrAgRmtNetAddr=chFbrAgRmtNetAddr, ltalkPortJam=ltalkPortJam, iwr=iwr, chHWType=chHWType, genPortActivityStatus=genPortActivityStatus, ethIntPortBackedUp=ethIntPortBackedUp, ethPortManPart=ethPortManPart, tokRingAgId=tokRingAgId, softRedundancy=softRedundancy, lseIntPortRetryPriorityLevel1=lseIntPortRetryPriorityLevel1, genGroupLastChange=genGroupLastChange, clGroupClockRedundancy=clGroupClockRedundancy, lseIntPortRoutingMode=lseIntPortRoutingMode, tokPortEntry=tokPortEntry, iwrIOMState=iwrIOMState, tsGroupLATStatus=tsGroupLATStatus, tokGroupManRightLoop=tokGroupManRightLoop, tokRingBeaconing=tokRingBeaconing, lseIntPortIgnoreProtocolType=lseIntPortIgnoreProtocolType, tokRingRightSlot=tokRingRightSlot, lseIntPortJabber=lseIntPortJabber, tokGroupAutoRightLoop=tokGroupAutoRightLoop, itrLinkAsyncRate=itrLinkAsyncRate, lseGroupEntry=lseGroupEntry, clGroupEntry=clGroupEntry, chNumberOfFDDIBuses=chNumberOfFDDIBuses, softRedundancyStatus=softRedundancyStatus, genGroupNumberOfPorts=genGroupNumberOfPorts, genGroupInterProcCommStatus=genGroupInterProcCommStatus, ethPortMJLP=ethPortMJLP, tokRingUtilization=tokRingUtilization, chFbrAgHubEnrollTraps=chFbrAgHubEnrollTraps, lseGroupId=lseGroupId, lseIntPortCompanyMAC=lseIntPortCompanyMAC, chHW=chHW, chFbrAgEntry=chFbrAgEntry, tokGroupRingGroupId=tokGroupRingGroupId, chHWPSUActivityStatus=chHWPSUActivityStatus, tokPortBypass=tokPortBypass, chFbrAgInterProcFaultTraps=chFbrAgInterProcFaultTraps, tokPortCableFault=tokPortCableFault, genGroupRedun12=genGroupRedun12, genGroupConfigurationSymbol=genGroupConfigurationSymbol, tokRingBeaconingStation=tokRingBeaconingStation, genGroupIntTemp=genGroupIntTemp, ethGroupBackboneMode=ethGroupBackboneMode, tokGroupAutoLinkLoop=tokGroupAutoLinkLoop, tokGroupAutoBusLoop=tokGroupAutoBusLoop, itrGroupEntry=itrGroupEntry, ethGroupId=ethGroupId, genIntPortId=genIntPortId, lseIntPortLearnIOCAM=lseIntPortLearnIOCAM, tokRingSecurityPolicy=tokRingSecurityPolicy, tokGroupSpecificOID=tokGroupSpecificOID, ethPortUserStatus=ethPortUserStatus, iwrGroupId=iwrGroupId, lLET3BoxOID=lLET3BoxOID, ethPortPacketErrors=ethPortPacketErrors, tokGroupRingId=tokGroupRingId, clPortTable=clPortTable, tokGroupRightNeighbor=tokGroupRightNeighbor, chFbrAgSWVersion=chFbrAgSWVersion, genIntPort=genIntPort, tokGroupTable=tokGroupTable, chFbrAgPermMngrAddr=chFbrAgPermMngrAddr, genIntPortBusConnType=genIntPortBusConnType, genGroupNumberOfIntPorts=genGroupNumberOfIntPorts, ethPortId=ethPortId, ethGroupFIFO=ethGroupFIFO, itrLinkTable=itrLinkTable, clPort=clPort, ethGroupMJLPStatus=ethGroupMJLPStatus, tokGroupEntry=tokGroupEntry, ethGroupIdleTrx=ethGroupIdleTrx, genGroupReset=genGroupReset, tokGroupManBusLoop=tokGroupManBusLoop, ethGroup10BTPlus=ethGroup10BTPlus, lseIntPortIgnoreBusy=lseIntPortIgnoreBusy, chFbrAgConfigurationSymbol=chFbrAgConfigurationSymbol, fbrOID=fbrOID, chFbrAgKernelVersion=chFbrAgKernelVersion, tokRingConfiguration=tokRingConfiguration, ethIntPortTable=ethIntPortTable, genGroupTable=genGroupTable, lseIntPort=lseIntPort, chHWIntTempWarning=chHWIntTempWarning, softRedundancyId=softRedundancyId, genPortEntry=genPortEntry, tokRingSecurityMethod=tokRingSecurityMethod, ethPortPygmys=ethPortPygmys, genIntPortMonitorMode=genIntPortMonitorMode, ethBusPeakTraffic=ethBusPeakTraffic, tokGroupRingInserted=tokGroupRingInserted, ethBusPeakUtilization=ethBusPeakUtilization, genGroupRedun34=genGroupRedun34, genPortDescr=genPortDescr, tokGroupRingSpeed=tokGroupRingSpeed, chHWPeakIntTemp=chHWPeakIntTemp, chFbrAgSoftwareStatus=chFbrAgSoftwareStatus, itrModuleState=itrModuleState, genIntPortSpecificOID=genIntPortSpecificOID, chFbrAgMaxNmbOfMngrs=chFbrAgMaxNmbOfMngrs, chHWPSUId=chHWPSUId, ethIntPort=ethIntPort, chNumberOfEthernetBuses=chNumberOfEthernetBuses, genPortSecureAddresses=genPortSecureAddresses, genPortSpecificOID=genPortSpecificOID, lseIntPortRetryPriorityLevel3=lseIntPortRetryPriorityLevel3, fbr2=fbr2, ethPortPartitions=ethPortPartitions, ltalkPortTable=ltalkPortTable, lseIntPortId=lseIntPortId, lseGroupBackBone=lseGroupBackBone, fbr101=fbr101, iwrGroupTable=iwrGroupTable, genGroupSWVersion=genGroupSWVersion, tokGroupId=tokGroupId, chFbrAgPermMngrId=chFbrAgPermMngrId, iwb=iwb, chGenAgTable=chGenAgTable, chHWPSUVoltage=chHWPSUVoltage, eth=eth, genGroupEntry=genGroupEntry, tokPortId=tokPortId, tokRing=tokRing, chFbrAgRmtNetId=chFbrAgRmtNetId, ethIntPortId=ethIntPortId, genPortType=genPortType, chMgrContPerfRep=chMgrContPerfRep, genGroupId=genGroupId, tokRingLeftSlot=tokRingLeftSlot, ethAgTable=ethAgTable, iwrWANPortCableType=iwrWANPortCableType, chFbrAgPermMngrTable=chFbrAgPermMngrTable, lseIntPortPriorityLevel=lseIntPortPriorityLevel, iwrWANConnection=iwrWANConnection, ethBusTotalPackets=ethBusTotalPackets, cl=cl, lseGroup10MSqlt=lseGroup10MSqlt, ltalkPortTestResult=ltalkPortTestResult, tokGroup=tokGroup, tokPortLastSourceAddr=tokPortLastSourceAddr, chFbrAgId=chFbrAgId, lseIntPortRxSafetyZone=lseIntPortRxSafetyZone, ethGroupEntry=ethGroupEntry, genGroupHWStatus=genGroupHWStatus, itrLinkMode=itrLinkMode, chFbrAgConfigChangeTraps=chFbrAgConfigChangeTraps, genGroupType=genGroupType, ethPortTable=ethPortTable, chFbrAgCommDebugMode=chFbrAgCommDebugMode, chMgrMngmtState=chMgrMngmtState, clPortEntry=clPortEntry, genPortSecurityPolicy=genPortSecurityPolicy, chFbrAgSensorFault=chFbrAgSensorFault, chFbrAgSLIPAddress=chFbrAgSLIPAddress, genGroupDescr=genGroupDescr, ethIntPortGroupId=ethIntPortGroupId, genPort=genPort, ethAgEntry=ethAgEntry, chGenAgType=chGenAgType, lseGroupSetDefaults=lseGroupSetDefaults, genPortIntPortConnection=genPortIntPortConnection, lLET36BoxOID=lLET36BoxOID, ethGroupMasterClock=ethGroupMasterClock, ethBusPerfAgId=ethBusPerfAgId, chFbrAgRmtNetTable=chFbrAgRmtNetTable)
mibBuilder.exportSymbols("FIBRONICS-MIB", chFbrAgIntTemp=chFbrAgIntTemp, ethPortAutoPartitionState=ethPortAutoPartitionState, tokGroupManLinkLoop=tokGroupManLinkLoop, fbrStack=fbrStack, lse=lse, softRedundancyName=softRedundancyName, lseIntPortTransmitWeight=lseIntPortTransmitWeight, ethBusPerfEntry=ethBusPerfEntry, ethAg=ethAg, ethPortFramesReceivedOK=ethPortFramesReceivedOK, itrLinkFunctionalStatus=itrLinkFunctionalStatus, softRedundancyTable=softRedundancyTable, genIntPortAdminStatus=genIntPortAdminStatus, ltalkPortId=ltalkPortId, lseIntPortVideoPacket=lseIntPortVideoPacket, ethIntPortEntry=ethIntPortEntry, lseIntPortActiveBroadcastPriority=lseIntPortActiveBroadcastPriority, lsePort=lsePort, ethBusTotalCollisions=ethBusTotalCollisions, ethBusClockTestResult=ethBusClockTestResult, chHWIntTempThresh=chHWIntTempThresh, ethGroupFOIRLPlusMode=ethGroupFOIRLPlusMode, lseIntPortVideoStateMachine=lseIntPortVideoStateMachine, lLET18BoxOID=lLET18BoxOID, chFbrAgInterProcFault=chFbrAgInterProcFault, lseGroupIPGDataLength=lseGroupIPGDataLength, lseGroupFastOpen=lseGroupFastOpen, tokRingSecureAddr=tokRingSecureAddr, ethPort=ethPort, ethIntPortJabber=ethIntPortJabber, chGenAgSpecificOID=chGenAgSpecificOID, ethBusClockBusId=ethBusClockBusId, chFbrAgCoprocCommStatus=chFbrAgCoprocCommStatus, chFbrAgCoprocSWVersion=chFbrAgCoprocSWVersion, genPortTable=genPortTable, tokGroupRingEntry=tokGroupRingEntry, ethGroup10FBPlus=ethGroup10FBPlus, fbrSecurity=fbrSecurity, tokPortTable=tokPortTable, fbrLanSwitch=fbrLanSwitch, ethGroupSingleBusMode=ethGroupSingleBusMode, chAg=chAg, chSlotLastChange=chSlotLastChange, itrLinkParityEvenOdd=itrLinkParityEvenOdd, tokGroupBridgeMode=tokGroupBridgeMode, iwrWANTable=iwrWANTable, chGenAgId=chGenAgId, itrLinkParity=itrLinkParity, genGroupKernelVersion=genGroupKernelVersion, ethBus=ethBus, lseGroupActiveMonitor=lseGroupActiveMonitor, iwrGroupEntry=iwrGroupEntry, itrConfigState=itrConfigState, tokRingTrafficThresh=tokRingTrafficThresh, chGenAgMgmtIfType=chGenAgMgmtIfType, chFbrAgRmtNetMask=chFbrAgRmtNetMask, ethGroupSpecificOID=ethGroupSpecificOID, chFbrAgMaxNmbOfNets=chFbrAgMaxNmbOfNets, deviceMgr=deviceMgr, tokGroupLeftNeighbor=tokGroupLeftNeighbor, chGenAgEntry=chGenAgEntry, chHWPSUTable=chHWPSUTable, iwrWANPortId=iwrWANPortId, chFbrAgSWFault=chFbrAgSWFault, lsePortGroupId=lsePortGroupId, probe=probe, chFbrAgRmtNetEntry=chFbrAgRmtNetEntry, lUnknownBoxOID=lUnknownBoxOID, tokRingStationsMatch=tokRingStationsMatch, chFbrAgReset=chFbrAgReset, tokRingTrafficBuffer=tokRingTrafficBuffer, itrMainSWVersion=itrMainSWVersion, tokPortConnected=tokPortConnected, chFbrAgTempThreshTraps=chFbrAgTempThreshTraps, chFbrAgBootVersion=chFbrAgBootVersion, tokGroupAutoLeftLoop=tokGroupAutoLeftLoop, ethBusUtilization=ethBusUtilization, ethPortNoAUILoop=ethPortNoAUILoop, tok=tok, chFbrAgSetup=chFbrAgSetup, genGroupCommStatus=genGroupCommStatus, tokPortSpecificOID=tokPortSpecificOID, itrLinkPortId=itrLinkPortId, tokRingTraffic=tokRingTraffic, iwrOperState=iwrOperState, lFDX100BoxOID=lFDX100BoxOID, genGroupStandAloneMode=genGroupStandAloneMode, ethGroup=ethGroup, ethBusPerfTable=ethBusPerfTable, genIntPortBusConnNumber=genIntPortBusConnNumber, tokRingId=tokRingId, chFbrAgTrafficThreshTraps=chFbrAgTrafficThreshTraps, clGroupTestClocks=clGroupTestClocks, lseIntPortTable=lseIntPortTable, ethPortTraffic=ethPortTraffic, lseIntPortRetryPriorityLevel2=lseIntPortRetryPriorityLevel2, itr=itr, genGroup=genGroup, tokRingTable=tokRingTable, tokPortRingSpeedError=tokPortRingSpeedError, lLET18EBoxOID=lLET18EBoxOID, chGenAgAddr=chGenAgAddr, ethAgPerfBusSelection=ethAgPerfBusSelection, itrLinkSyncRate=itrLinkSyncRate, ethAgId=ethAgId, tokRingLastViolation=tokRingLastViolation, softRedundancyGroupId1=softRedundancyGroupId1, tsGroupEntry=tsGroupEntry, lsePortTable=lsePortTable, genGroupRedun13_14=genGroupRedun13_14, ethBusTrafficBuffer=ethBusTrafficBuffer, bRouter=bRouter, tokRingNumberOfStations=tokRingNumberOfStations, ethBusClockEntry=ethBusClockEntry, ethIntPortPartition=ethIntPortPartition, chFullConfig=chFullConfig, ethBusTraffic=ethBusTraffic, genPortFunctionality=genPortFunctionality, ethGroupWrongPortSelection=ethGroupWrongPortSelection, chMgrTrapRepStatus=chMgrTrapRepStatus, tsGroup=tsGroup, ltalkPortGroupId=ltalkPortGroupId, softRedundancyGroupId2=softRedundancyGroupId2, genPortGroupId=genPortGroupId, itrLinkIf=itrLinkIf, clGroupId=clGroupId, tsGroupOperationMode=tsGroupOperationMode, chFbrAgSensorFaultTraps=chFbrAgSensorFaultTraps, chHWPSULocation=chHWPSULocation, lseGroupIPGJamLength=lseGroupIPGJamLength, tokGroupManLeftLoop=tokGroupManLeftLoop, genIntPortEntry=genIntPortEntry, tokRingPeakUtilization=tokRingPeakUtilization, ethPortFIFO=ethPortFIFO, tsGroupTable=tsGroupTable, lSTACKBoxOID=lSTACKBoxOID, genIntPortTable=genIntPortTable, chFbrAgTable=chFbrAgTable, softRedundancyPortId2=softRedundancyPortId2, lseIntPortGroupId=lseIntPortGroupId, tokGroupIOMode=tokGroupIOMode, lseIntPortGlobal=lseIntPortGlobal, ethPortCollisions=ethPortCollisions, lseIntPortSuperPriorityEnable=lseIntPortSuperPriorityEnable, lBoxOID=lBoxOID, chFbrAgPermMngrEntry=chFbrAgPermMngrEntry, tokRingEntry=tokRingEntry, genGroupSupplyVoltageFault=genGroupSupplyVoltageFault, genIntPortActivityStatus=genIntPortActivityStatus, chFbrAgLastAddrConfig=chFbrAgLastAddrConfig)
