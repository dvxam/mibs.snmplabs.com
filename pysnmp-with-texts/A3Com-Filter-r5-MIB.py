#
# PySNMP MIB module A3COM-FILTER-R5-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/tin/Dev/mibs.snmplabs.com/asn1/A3COM-FILTER-R5-MIB
# Produced by pysmi-0.3.4 at Fri Jan 31 21:32:20 2020
# On host bier platform Linux version 5.4.0-3-amd64 by user tin
# Using Python version 3.7.6 (default, Jan 19 2020, 22:34:52) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint")
MacAddress, = mibBuilder.importSymbols("RFC1286-MIB", "MacAddress")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, ObjectIdentity, Unsigned32, iso, MibIdentifier, enterprises, Gauge32, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Integer32, Counter64, IpAddress, Counter32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "ObjectIdentity", "Unsigned32", "iso", "MibIdentifier", "enterprises", "Gauge32", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Integer32", "Counter64", "IpAddress", "Counter32", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
a3Com = MibIdentifier((1, 3, 6, 1, 4, 1, 43))
brouterMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2))
a3ComFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 10))
a3ComFilterCtl = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 2, 10, 1))
class RowStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6))

a3filterControl = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enableMatchOne", 1), ("enableCheckAll", 2), ("disable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterControl.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterControl.setDescription('This object enables/disables the filtering function. If this object is set to disable (2), filtering is turned off for all protocols. If the control is set to enableMatchOne (1) or enableCheckAll (2), then filtering is performed on protocols that are selected via the a3filter*Select objects and those for which at least one policy is configured. If a packet matches the Masks defined for more than one Policy and this object is set to enableMatchOne, only the action associated with the first satisfied Policy is performed. If this object is set to enableCheckAll (2), however, the actions associated with each satisfied Policy is performed.')
a3filterDefaultAction = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discard", 1), ("forward", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterDefaultAction.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterDefaultAction.setDescription('This object specifies the action applied to a packet if it does not match any of the policies configured or if two conflicting policies are specified and the the packet meets criteria associated with both.')
a3filterBridgeSelect = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("filter", 1), ("noFilter", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterBridgeSelect.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterBridgeSelect.setDescription('This object determines whether the filter function will be invoked for the Bridge (or datalink) protocol layer. This provides a mechanism for deselecting filtering for this protocol layer while retaining the policies and masks configured for this protocol.')
a3filterIpSelect = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("filter", 1), ("noFilter", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterIpSelect.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterIpSelect.setDescription('This object determines whether the filter function will be invoked for the IP protocol layer. This provides a mechanism for deselecting filtering for this protocol layer while retaining the policies and masks configured for this protocol.')
a3filterIpxSelect = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("filter", 1), ("noFilter", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterIpxSelect.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterIpxSelect.setDescription('This object determines whether the filter function will be invoked for the IPX protocol layer. This provides a mechanism for deselecting filtering for this protocol layer while retaining the policies and masks configured for this protocol.')
a3filterAppleTalkSelect = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("filter", 1), ("noFilter", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterAppleTalkSelect.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterAppleTalkSelect.setDescription('This object determines whether the filter function will be invoked for the Apple Talk protocol layer. This provides a mechanism for deselecting filtering for this protocol layer while retaining the policies and masks configured for this protocol.')
a3filterDecSelect = MibScalar((1, 3, 6, 1, 4, 1, 43, 2, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("filter", 1), ("noFilter", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterDecSelect.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterDecSelect.setDescription('This object determines whether the filter function will be invoked for the DECnet protocol layer. This provides a mechanism for deselecting filtering for this protocol layer while retaining the policies and masks configured for this protocol.')
a3filterUserMaskTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 10, 2), )
if mibBuilder.loadTexts: a3filterUserMaskTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserMaskTable.setDescription('A table containing User configured Masks that are used to identify specific classes of packets. These masks are used by the policy table to define actions to take on these classes of packets.')
a3filterUserMaskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 10, 2, 1), ).setIndexNames((0, "A3COM-FILTER-R5-MIB", "a3filterUserMaskIndex"))
if mibBuilder.loadTexts: a3filterUserMaskEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserMaskEntry.setDescription('The definition of a single Mask.')
a3filterUserMaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3filterUserMaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserMaskIndex.setDescription('An index identifying a specific Mask. All user configured masks must have an index between 1 and 64.')
a3filterUserMaskName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterUserMaskName.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserMaskName.setDescription('A text string used to help identify a specific Mask. Each entry must have a unique name.')
a3filterUserMaskLocType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("protocolFieldSemantics", 1), ("offsetLengthSemantics", 2), ("dataLinkOffsetLengthSemantics", 3), ("ipOffsetLengthSemantics", 4), ("ipxOffsetLengthSemantics", 5), ("appleTalkOffsetLengthSemantics", 6), ("decNetOffsetLengthSemantics", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterUserMaskLocType.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserMaskLocType.setDescription('This object determines if this table entry specifies packet location via the mnemonic, protocol.field semantics or via the numerical offset.length semantics. If this object is set to protocolFieldSemantics (1), then the value of a3filterUserMaskLocField is used to identify the packet location where the mask is applied. If this object is set to offsetLengthSemantics(2), then the offset and lengths identified by a3filterUserMaskLocOffset and a3filterUserMaskLocLength are measured from the start of the datalink layer. If this object is set to dataLinkOffsetLengthSemantics(3), then the value of a3filterUserMaskLocOffset and a3filterUserMaskLocLength are used to determine where the mask is applied. The offset and length are measured starting from the data field of the data link protocol layer. If this object is set to ipOffsetLengthSemantics(4), then the value of a3filterUserMaskLocOffset and a3filterUserMaskLocLength are used to determine where the mask is applied. The offset and length are measured starting from the data field of the IP protocol layer. If this object is set to appleTalkOffsetLengthSemantics(5), then the value of a3filterUserMaskLocOffset and a3filterUserMaskLocLength are used to determine where the mask is applied. The offset and length are measured starting from the data field of the AppleTalk protocol layer. Similar semantics apply to the remaining enumerations for this object.')
a3filterUserMaskLocField = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47))).clone(namedValues=NamedValues(("dlDestinationAddress", 1), ("dlSourceAddress", 2), ("dlAddress", 3), ("dlProtocol", 4), ("dlLength", 5), ("dlDSAP", 6), ("dlSSAP", 7), ("dlLSAP", 8), ("dlOUI", 9), ("dlLanID", 10), ("ipDestAddress", 11), ("ipSourceAddress", 12), ("ipAddress", 13), ("ipProtocol", 14), ("ipDestinationPort", 15), ("ipSourcePort", 16), ("ipPort", 17), ("ipOptions", 18), ("ipTOS", 19), ("ipxDestNetwork", 20), ("ipxSourceNetwork", 21), ("ipxNetwork", 22), ("ipxDestAddress", 23), ("ipxSourceAddress", 24), ("ipxAddress", 25), ("ipxDestSocket", 26), ("ipxSourceSocket", 27), ("ipxSocket", 28), ("atDestinationNetwork", 29), ("atSourceNetwork", 30), ("atNetwork", 31), ("atDestinationNodeID", 32), ("atSourceNodeID", 33), ("atNodeID", 34), ("atDestinationSocket", 35), ("atSourceSocket", 36), ("atSocket", 37), ("atDDPType", 38), ("decDestinationArea", 39), ("decSourceArea", 40), ("decArea", 41), ("decDestAddress", 42), ("decSourceAddress", 43), ("decAddress", 44), ("ipxPktLength", 45), ("ipxPktType", 46), ("ipxTransportCtl", 47)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterUserMaskLocField.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserMaskLocField.setDescription('This object specifies the location in the packet where the operation should take place. This object takes effect only when a3filterUserMaskLocationType has the value protocolFieldSemantics(1). Otherwise, this object is ignored.')
a3filterUserMaskLocOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterUserMaskLocOffset.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserMaskLocOffset.setDescription('When specifying a packet location via the offsetLength semantics, this parameters indicates the offset from the beginning of the portion of the protocol layer identified by a3filterUserMaskLocationType that is used in the Mask.')
a3filterUserMaskLocLength = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("reserved", 3), ("four", 4), ("rsvd", 5), ("six", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterUserMaskLocLength.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserMaskLocLength.setDescription('When specifying a packet location via the offsetLength semantics, this parameter indicates the length of the bit field used in the Mask. Only the values one(1), two(2), four(4), and six(6) are allowed. If the length is not specified, the agent will automatically determine the proper length based on either the operand (a3filterUserMaskOperand) or the matching values (a3filterUserMaskMatchType).')
a3filterUserMaskOperator = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("or", 2), ("and", 3), ("xor", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterUserMaskOperator.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserMaskOperator.setDescription('This object, together with a3filterUserMaskOperand, cause bit operations to be performed on the bit field identified by a3filterUserMaskLocation. The output of this operation is compared, according to a3filterUserMaskComparison, to the value specified by a3filterUserMaskMatch.')
a3filterUserMaskOperand = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 2, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterUserMaskOperand.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserMaskOperand.setDescription('This object, together with a3filterUserMaskOperator, cause bit operations to be performed on the bit field identified by a3filterUserMaskLocation. The output of this operation is compared, according to a3filterUserMaskComparison, to the value specified by a3filterUserMaskMatchType and a3filterUserMaskMatchBits, a3filterUserMaskMatchValue1, and/or a3filterUserMaskMatchValue2 (depending on the value of a3filterUserMaskMatchType. ie, the value of a3filterUserMaskMatchType determines which of the other objects are relevant).')
a3filterUserMaskComparison = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("equal", 1), ("notEqual", 2), ("greaterThan", 3), ("greaterThanOrEqual", 4), ("lessThan", 5), ("lessThanOrEqual", 6), ("inclusiveRange", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterUserMaskComparison.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserMaskComparison.setDescription('This object specifies the type of comparison to make between the output of the operation specified by a3filterUserMaskLocation, a3filterUserMaskOperator, a3filterUserMaskOperand, and a3filterUserMaskMatch.')
a3filterUserMaskMatchType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("all", 1), ("bits", 2), ("value", 3), ("valueRange", 4), ("userGroup", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterUserMaskMatchType.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserMaskMatchType.setDescription('This object specifies the type of data that is being matched. The value of this object determines which column(s) are relevant for this entry. If this object is set to all(1), any value is considered as matching, and the values of the following columns are ignored: a3filterUserMaskMatchBits, a3filterUserMaskMatchValue1, and a3filterUserMaskMatchValue2. If this object is set to bits(2), then the packet location identified by the *Loc* columns (and after the indicated bit operations) is compared to the bits identified by a3filterUserMaskMatchBits. The values of a3filterUserMaskMatchValue1 and a3filterUserMaskMatchValue2 are ignored in this case. If this object is set to value(3), then the value contained in the specified packet location is compared to the value specified by a3filterUserMaskMatchValue1. The values of a3filterUserMaskMatchBits and a3filterUserMaskMatchValue2 are ignored in this case. If this object is set to valueRange(4), then the value contained in the specified packet location is compared to the range of values specified by a3filterUserMaskMatchValue1 and a3filterUserMaskMatchValue2. The value of a3filterUserMaskMatchBits is ignored in this case. Finally, if this object is set to userGroup(5), then the MAC address contained in the specified packet location is compared to the members of the User Group identified by a3filterUserMaskMatchValue1. In this case, the value of a3filterUserMaskMatchValue1 identifies one or more entries in a3filterUserGrpAddrTable. The values of a3filterUserMaskMatchBits and a3filterUserMaskMatchValue2 are ignored.')
a3filterUserMaskMatchBits = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 2, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterUserMaskMatchBits.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserMaskMatchBits.setDescription('A string of bits that is compared against the data at the specified location in the packet. This object is relevant only if a3filterUserMaskMatchType is (2).')
a3filterUserMaskMatchValue1 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 2, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterUserMaskMatchValue1.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserMaskMatchValue1.setDescription('The value used to compare against the data at the specified location in the packet. This object is relevant only if the value of a3filterUserMaskMatchType is (3), (4), or (5).')
a3filterUserMaskMatchValue2 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 2, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterUserMaskMatchValue2.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserMaskMatchValue2.setDescription('The value used to compare against the data at the specified location in the packet. This object is used along with a3filterUserMaskMatchValue1 to specify a range of values. This object is relevant only if a3filterUserMaskMatchType is (4).')
a3filterUserMaskStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 2, 1, 14), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterUserMaskStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserMaskStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB. Note, if this mask entry is being used by an active Policy entry, it can not be removed.')
a3filterBuiltInMaskTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 10, 3), )
if mibBuilder.loadTexts: a3filterBuiltInMaskTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterBuiltInMaskTable.setDescription('A table containing Built In Masks that are used to identify specific classes of packets. These masks may be used by the policy table to define actions to take on these classes of packets.')
a3filterBuiltInMaskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 10, 3, 1), ).setIndexNames((0, "A3COM-FILTER-R5-MIB", "a3filterBuiltInMaskIndex"))
if mibBuilder.loadTexts: a3filterBuiltInMaskEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterBuiltInMaskEntry.setDescription('The definition of a single Built In Mask.')
a3filterBuiltInMaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(257, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3filterBuiltInMaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterBuiltInMaskIndex.setDescription('This object uniquely identifies a Built In Mask. This index is also used by the Policy Table to identify Masks, both Built In and User Defined.')
a3filterBuiltInMaskName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3filterBuiltInMaskName.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterBuiltInMaskName.setDescription('The name assigned to a Built In Mask. Each name is unique and applies when referring to the Mask from the User Interface.')
a3filterBuiltInMaskFieldValue = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60))).clone(namedValues=NamedValues(("dlBroadCast", 1), ("dlMultiCast", 2), ("appleTalkII", 3), ("aarp", 4), ("arp", 5), ("clnp", 6), ("decPhaseIV", 7), ("dlTest", 8), ("ip", 9), ("ipx", 10), ("lat", 11), ("ipNetMap", 12), ("xnsNetMap", 13), ("stp", 14), ("vip", 15), ("xns", 16), ("specificRoute", 17), ("singleRouteExp", 18), ("allRouteExp", 19), ("allRouteType", 20), ("icmp", 21), ("tcp", 22), ("udp", 23), ("dns", 24), ("finger", 25), ("ftp", 26), ("whois", 27), ("simpleMailTrans", 28), ("snmp", 29), ("sunRPC", 30), ("telnet", 31), ("tftp", 32), ("x400", 33), ("zero", 34), ("one", 35), ("two", 36), ("three", 37), ("four", 38), ("five", 39), ("six", 40), ("seven", 41), ("ipxBroadCast", 42), ("fileServicePkt", 43), ("sap", 44), ("rip", 45), ("netBIOS", 46), ("diag", 47), ("rtmps", 48), ("nis", 49), ("zis", 50), ("rtmprs", 51), ("nbp", 52), ("atp", 53), ("aep", 54), ("rtmprq", 55), ("zip", 56), ("adsp", 57), ("ipxTraceRt", 58), ("ipxPing", 59), ("ipxNwSec", 60)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3filterBuiltInMaskFieldValue.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterBuiltInMaskFieldValue.setDescription('This object identifies the value that this Built In Mask looks for as well as the protocol field. Note, the way this table defines a Mask is different from the semantics of the User Mask table. In that table, Masks look for specific values in specific protocol fields. Built In Masks, however, are different. For example, one Built In Mask looks for the value ip(9) in the field dataLinkProtocol(2). Besides looking in the dataLinkProtocol field, the code that implements this mask also looks for IP in the proper SNAP field when the dataLinkProtocol field indicates SNAP.')
a3filterUserGrpTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 10, 4), )
if mibBuilder.loadTexts: a3filterUserGrpTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserGrpTable.setDescription('A table containing User Group entries. Each entry identifies a set of entries in the a3filterUserGrpAddrTable which can contain several station Addresses. These addresses are physical layer addresses. This table is used to associate a single User Group index with a name.')
a3filterUserGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 10, 4, 1), ).setIndexNames((0, "A3COM-FILTER-R5-MIB", "a3filterUserGrpIndex"))
if mibBuilder.loadTexts: a3filterUserGrpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserGrpEntry.setDescription('Each entry in this table identifies a group of station addresses.')
a3filterUserGrpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3filterUserGrpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserGrpIndex.setDescription('Each entry in this table identifies a group of station addresses.')
a3filterUserGrpName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterUserGrpName.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserGrpName.setDescription('The name given to this group of station addresses.')
a3filterUserGrpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 4, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterUserGrpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserGrpStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB.')
a3filterUserGrpAddrTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 10, 5), )
if mibBuilder.loadTexts: a3filterUserGrpAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserGrpAddrTable.setDescription('A table containing User Group addresses. Each entry can contain several station Addresses. These addresses are physical layer addresses. Note, this table applies only to filtering based on the Data Link layer. Since only bridged packets are filtered at this layer, this table only applies to bridged traffic.')
a3filterUserGrpAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 10, 5, 1), ).setIndexNames((0, "A3COM-FILTER-R5-MIB", "a3filterUserGrpAddrIndex"), (0, "A3COM-FILTER-R5-MIB", "a3filterUserGrpAddress"))
if mibBuilder.loadTexts: a3filterUserGrpAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserGrpAddrEntry.setDescription('Each entry in this table identifies a single station address.')
a3filterUserGrpAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3filterUserGrpAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserGrpAddrIndex.setDescription('This is used to identify a group of station addresses. This object has the same value as a3filterUserGrpIndex.')
a3filterUserGrpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 5, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3filterUserGrpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserGrpAddress.setDescription('A single station physical address.')
a3filterUserGrpAddrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 5, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterUserGrpAddrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterUserGrpAddrStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB.')
a3filterPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 43, 2, 10, 6), )
if mibBuilder.loadTexts: a3filterPolicyTable.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterPolicyTable.setDescription('A table containing filtering Policy. Each Policy applies a set of selection criteria (Masks) to a context (in terms of ports or station groups) and associates an action with that application.')
a3filterPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 2, 10, 6, 1), ).setIndexNames((0, "A3COM-FILTER-R5-MIB", "a3filterPolicyIndex"))
if mibBuilder.loadTexts: a3filterPolicyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterPolicyEntry.setDescription('The definition of a single Policy.')
a3filterPolicyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3filterPolicyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterPolicyIndex.setDescription('The index used to identify a filter policy entry.')
a3filterPolicyName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterPolicyName.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterPolicyName.setDescription('A textual name used to help identify a filter policy entry. Each entry must have a unique name.')
a3filterPolicyAction = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("discard", 1), ("forward", 2), ("count", 3), ("sequence", 4), ("prioritizeHigh", 5), ("prioritizeMed", 6), ("prioritizeLow", 7), ("doddiscard", 8), ("x25ProfId", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterPolicyAction.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterPolicyAction.setDescription("The action taken when a packet matches all the masks (applied in the proper context) identified in this policy entry. If this object has the value discard(1), then all packets that match the masks and context of this entry are discarded. If this object has the value forward(2), then all packets that match the masks and context of this entry are forwarded. If this object has the value count(3), then all packets that match the masks and context of this entry are counted. The actual counts can be obtained by requesting the values of a3filterPolicyPackets and a3filterPolicyBytes. If this object has the value sequence(4), then all bridged packets destined for a port with multiple serial paths that match the masks and context of this entry are forwarded in sequence. If this object has the value prioritze, then all packets destined for a port supported by one or more serial paths that match the masks and context of this entry are given higher priority. If this object has the value doddiscard(8), then all packets that match the masks and context of this entry will be subjected to the 'DODdiscard' action; ie, those packets will be discarded and will not raise a DOD path if the path is down, or if the path is UP, those packets will be forwarded but will not keep the path up. If this object has the value x25ProfId(9), then all packets that match the masks and context of this entry will use the X25 Profile identified by a3filterPolicyX25ProfId when passing those packets over an X25 network.")
a3filterPolicyMask1 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 6, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterPolicyMask1.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterPolicyMask1.setDescription('This object identifies an entry in either of the Mask Tables. Each filter policy entry identifies up to four separate masks. An entry of zero for this object identifies a null mask.')
a3filterPolicyMask2 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 6, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterPolicyMask2.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterPolicyMask2.setDescription('This object identifies an entry in either of the Mask Tables. Each filter policy entry identifies up to four separate masks. An entry of zero for this object identifies a null mask.')
a3filterPolicyMask3 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 6, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterPolicyMask3.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterPolicyMask3.setDescription('This object identifies an entry in the Mask Table. Each filter policy entry identifies up to four separate masks. An entry of zero for this object identifies a null mask.')
a3filterPolicyMask4 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 6, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterPolicyMask4.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterPolicyMask4.setDescription('This object identifies an entry in the Mask Table. Each filter policy entry identifies up to four separate masks. An entry of zero for this object identifies a null mask.')
a3filterPolicyContext = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("all", 1), ("atPorts1", 2), ("fromPorts1", 3), ("fromPorts1ToPorts2", 4), ("toPorts1", 5), ("betweenPorts1AndPorts2", 6), ("amongPorts1", 7))).clone('all')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterPolicyContext.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterPolicyContext.setDescription('Supplies conditions on when to apply the masks to a packet. These conditions relate to the source and destination ports of a packet. All (1) means apply the action in all contexts. AT (2) means apply the action if the packet is received from or distined to the ports specified by a3filterPolicyPorts1. TO (3) means apply the action if the packet is destined to those ports. FROM (4) means apply the action if the packet is received from one of those specified ports. FROM ports1 TO ports2 (5) means apply the action if the packet is received from the ports defined by a3filterPolicyPorts1 and destined to the port defined by a3filterPolicyPorts2. BETWEEN ports1 AND ports2 (6) means apply the action if the packet is received from one of the ports defined by a3filterPolicyPorts1 and destined for one of the ports defined by a3filterPolicyPorts2 or if the packet is received from one of the ports defined by a3filterPolicyPorts2 and destined for one of the ports defined by a3filterPolicyPorts1. Finally AMONG (7) means apply the action if the packet is received from and destined to one of the ports specified by a3filterPolicyPorts1')
a3filterPolicyPorts1 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 6, 1, 9), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterPolicyPorts1.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterPolicyPorts1.setDescription("This object identifies one or more ports. These ports are used to help identify in what contexts masks are applied. This is used in conjunction with a3filterPolicyContext. Each octet within the value of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each port of the bridge is represented by a single bit within the value of this object. If that bit has a value of '1' then that port is included in the set of ports; the port is not included if its bit has a value of '0'. (Note that the setting of the bit corresponding to the port from which a frame is received is irrelevant.)")
a3filterPolicyPorts2 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 6, 1, 10), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterPolicyPorts2.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterPolicyPorts2.setDescription("This object identifies one or more ports. These ports are used to help identify in what contexts masks are applied. This is used in conjunction with a3filterPolicyContext. Each octet within the value of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each port of the bridge is represented by a single bit within the value of this object. If that bit has a value of '1' then that port is included in the set of ports; the port is not included if its bit has a value of '0'. (Note that the setting of the bit corresponding to the port from which a frame is received is irrelevant.) Note, this object only applies if a3filterPolicyContext has the value fromPorts1ToPorts2 (5) or betweenPorts1AndPorts2 (6) or amongPorts1(7).")
a3filterPolicyPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3filterPolicyPackets.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterPolicyPackets.setDescription('The number of packets that match the policy defined by this entry.')
a3filterPolicyBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a3filterPolicyBytes.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterPolicyBytes.setDescription('The total number of bytes in the packets that match the policy defined by this entry.')
a3filterPolicyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 6, 1, 13), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterPolicyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterPolicyStatus.setDescription('This object is used to add and delete entries in this table. See the notes describing RowStatus at the beginning of this MIB.')
a3filterPolicyX25ProfId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 2, 10, 6, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a3filterPolicyX25ProfId.setStatus('mandatory')
if mibBuilder.loadTexts: a3filterPolicyX25ProfId.setDescription('The index used to identify the X25 Profile ID if a3filterPolicyAction is set to X25ProfId.')
mibBuilder.exportSymbols("A3COM-FILTER-R5-MIB", a3filterUserMaskOperand=a3filterUserMaskOperand, a3filterUserMaskName=a3filterUserMaskName, a3filterUserGrpIndex=a3filterUserGrpIndex, a3filterUserMaskMatchValue1=a3filterUserMaskMatchValue1, a3filterPolicyMask1=a3filterPolicyMask1, a3filterIpxSelect=a3filterIpxSelect, a3filterPolicyStatus=a3filterPolicyStatus, a3filterBuiltInMaskIndex=a3filterBuiltInMaskIndex, a3filterDefaultAction=a3filterDefaultAction, a3filterIpSelect=a3filterIpSelect, a3filterUserGrpTable=a3filterUserGrpTable, a3filterUserMaskComparison=a3filterUserMaskComparison, a3filterBuiltInMaskEntry=a3filterBuiltInMaskEntry, a3filterPolicyX25ProfId=a3filterPolicyX25ProfId, a3filterPolicyPorts1=a3filterPolicyPorts1, a3filterUserGrpAddress=a3filterUserGrpAddress, a3filterUserMaskOperator=a3filterUserMaskOperator, a3filterPolicyMask2=a3filterPolicyMask2, a3filterBridgeSelect=a3filterBridgeSelect, a3filterUserGrpAddrIndex=a3filterUserGrpAddrIndex, a3filterUserMaskLocLength=a3filterUserMaskLocLength, a3filterAppleTalkSelect=a3filterAppleTalkSelect, a3filterUserGrpEntry=a3filterUserGrpEntry, a3filterUserMaskEntry=a3filterUserMaskEntry, a3ComFilter=a3ComFilter, a3filterUserMaskLocType=a3filterUserMaskLocType, a3filterUserMaskMatchType=a3filterUserMaskMatchType, a3filterBuiltInMaskName=a3filterBuiltInMaskName, a3filterUserGrpAddrEntry=a3filterUserGrpAddrEntry, RowStatus=RowStatus, a3filterPolicyEntry=a3filterPolicyEntry, a3filterUserMaskMatchValue2=a3filterUserMaskMatchValue2, a3filterUserMaskMatchBits=a3filterUserMaskMatchBits, a3filterBuiltInMaskFieldValue=a3filterBuiltInMaskFieldValue, a3filterUserGrpAddrTable=a3filterUserGrpAddrTable, a3filterPolicyName=a3filterPolicyName, a3filterUserMaskStatus=a3filterUserMaskStatus, a3filterUserGrpStatus=a3filterUserGrpStatus, a3filterUserGrpAddrStatus=a3filterUserGrpAddrStatus, a3filterPolicyContext=a3filterPolicyContext, a3filterPolicyPorts2=a3filterPolicyPorts2, a3filterBuiltInMaskTable=a3filterBuiltInMaskTable, a3filterUserMaskIndex=a3filterUserMaskIndex, a3filterUserGrpName=a3filterUserGrpName, a3filterPolicyMask4=a3filterPolicyMask4, a3filterPolicyAction=a3filterPolicyAction, a3filterPolicyBytes=a3filterPolicyBytes, a3filterUserMaskLocField=a3filterUserMaskLocField, a3filterUserMaskLocOffset=a3filterUserMaskLocOffset, a3filterPolicyPackets=a3filterPolicyPackets, a3ComFilterCtl=a3ComFilterCtl, a3filterPolicyMask3=a3filterPolicyMask3, a3filterUserMaskTable=a3filterUserMaskTable, a3Com=a3Com, brouterMIB=brouterMIB, a3filterPolicyTable=a3filterPolicyTable, a3filterControl=a3filterControl, a3filterPolicyIndex=a3filterPolicyIndex, a3filterDecSelect=a3filterDecSelect)
